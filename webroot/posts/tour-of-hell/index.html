<!DOCTYPE html>
<html><head>
    <style>
      body {
          max-width: 60em;
          margin: .5in auto;
          font-size: 18px;
          font-family: serif;
          line-height: 1.5;
      }
      h1,h2,h3,h4,h5,h6 {
          font-family: Helvetica;
      }
      code, pre { background: #eee; border: #aaa; border-radius: 3px;
             padding: 0.2em 0.5em }
      h1 a,h2 a,h3 a,h4 a {
          color: inherit;
      }
      @media(max-width:767px){
          body { margin: 1px 4px; }
          h1, h2, .menu { margin: 0; }
          h1 { font-size: 1.5em; }
          h2 { font-size: 1.125em; }
          h3 { font-size: 1.0125em; }
      }
      .slides { display: flex; flex-direction: column; row-gap: 2em }
      .slide { display: flex; flex-direction: row; column-gap: 2em; }
      .slide p, .slide li { line-height: 1.8em; text-align: justify; }
      .slide a {
          text-decoration: none;
      }
      .slide p a { text-decoration: underline }
      .slide img {
          width: 20em; border: 1px solid #ddd; border-radius: 3px;
          box-shadow: 0.1em 0.1em 0.1em 0.1em rgba(100, 100, 100, .1);
      }
      .slide p:first-child {
          margin-top: 0;
      }
      .date { margin-bottom: 2em; padding-top: 0em; }
    </style>
  </head>
  <body>
    <h1>A Tour of Hell</h1>
    <p class="date"><em>Feb 9th 2024</em></p>
    <div class="slides">
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-9.png"><img src="slide-9.png"></a>
        <div>
          <p>This set of slides sketches out the solution, as an
            implementation, in technical detail.</p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-11.png"><img src="slide-11.png"></a>
        <div>
          <p>There are a few limits on the language; no imports, no
            polymorphism (poly types) i.e. no declaration is ever
            inferred with a <code>forall a.</code> in it. Poly types are
            awesome, but they make the implementation harder, and are a
            form of abstraction that you might not need in a scripting
            language. I don't need them in my case, YMMV.
          </p>
          <p>
            No imports: instead, all names that usually come under a
            package name like <code>async</code>
            become <code>Async.race</code>, <code>List.map</code>,
            etc. All identifiers are explicitly qualified except
            lambda parameters: <code>\x -&gt; x</code> -- not qualified.
          </p>
          <p>
            Recursion is completely ruled out, but <code>fix</code>
            works fine, so you still have it as a primitive
            function. It's just not something you can produce
            yourself.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-15.png"><img src="slide-15.png"></a>
        <div>
          <p>
            Rather than bothering to implement a parser, I used
            haskell-src-exts. That package isn't really maintained
            anymore, but I'm kind of used to it now, and GHC's parser is
            a bit too wordy for me.
          </p>
          <p>
            Re-using a parser is usually wise, parsing layout in Haskell
            is fiddly and I just wanted something that works as I'm used
            to.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-16.png"><img src="slide-16.png"></a>
        <div>
          <p>
            The next step is to desugar this syntax into something
            smaller. <code>do</code>-notation becomes
            nested <code>&gt;&gt;=</code> calls, etc.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-17.png"><img src="slide-17.png"></a>
        <div>
          <p>
            Parsing is the beginning of the pipeline. For this
            project, a primary concern was to make the evaluator as
            lean as possible, and, ideally,
            <a href="https://en.wikipedia.org/wiki/Partial_function">total</a>
            and complete. With this in mind, I started at the
            interpreter and worked backwards from there. What does a
            trivial but total evaluator look like in Haskell?
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-18.png"><img src="slide-18.png"></a>
        <div>
          <p>
            Here's a basic one. It's called "higher-order abstract
            syntax" because you've got syntax productions that take
            functions as arguments. Rather than carrying an
            environment around, like in,
            e.g. <a href="https://norvig.com/lispy.html">How to Write
              a (Lisp) Interpreter (in Python)</a>, you store a
            function <em>as a real function</em>. When you pass an
            environment around, you tend to have a lookup function
            that could throw an error if you got your evaluator wrong.
          </p>
          <p>
            This evaluator is <em>total</em> and won't crash. This is
            really neat and tidy. The only downside really is that
            it's opaque. It's hard to work with functions, because you
            can't look inside them once you've made them. You also
            can't smooth out the wrinkles inside them, at least, as
            far as I'm aware. I've heard of cunning approaches to do
            so, but some things are best left alone.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-19.png"><img src="slide-19.png"></a>
        <div>
          <p>
            I encountered another approach while perusing Oleg
            Kiselyov's
            <a href="https://okmij.org/ftp/tagless-final/course/lecture.pdf"><em>Typed Tagless Final Interpreters</em></a> paper and he dropped in
            this example like it was the most normal thing in the
            world. I'm not sure where Oleg got this from.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-20.png"><img src="slide-20.png"></a>

        <div>
          <p>
            This evaluator is not higher order. It features environment lookup and
            the evaluator carries around an environment. But there's something
            clever here: that lookup will always succeed.
          </p>
          <p>
            The environment is a simple stack of tuples. When
            evaluating a lambda, simply wrap the environment in
            another tuple with the argument being passed.
          </p>
          <p>
            Variables are church numerals: 0 is <code>VZ</code>, 1
            is <code>VS VZ</code>, 2 is <code>VS (VS VZ)</code>, etc.
            It's
            a <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de
            Bruijn index</a> that is statically typed. It means "how
            far up the stack do you go?" Lookup simply walks both the
            church numeral and the environment until the zero case
            (<code>VZ</code>) is reached, and then what's there in the
            stack is returned.
          </p>
          <p>
            The way to make this total and guaranteed to be correct is via the
            <code>env</code> type parameter that both the <code>Exp</code> type and the <code>Var</code> type
            share.
            It took me a few readings to believe that this actually works. It's
            beautiful.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-21.png"><img src="slide-21.png"></a>
        <div>
          <p>Hell's core AST and evaluator are almost identical, with a couple
            adjustments.</p>

          <ol>
            <li>Oleg's example hard-codes Bool just for demonstration
              purposes. Hell's AST has <code>Lit</code> instead, which can produce any
              <code>a</code>. All primitive functions e.g. <code>List.map</code> or e.g. literals like
              <code>123</code> are kept in there.</li>
            <li>
              In the zero case for <code>Var</code>, Hell keeps a function as a final
              accessor function. This lets us easily pull out a tuple slot from a
              function argument, e.g. <code>\(x,y) -&gt; x</code> becomes, conceptually, <code>\xy
                -&gt; fst x</code>. This could later possibly be used for e.g. <code>\X{x,y} -&gt;
                x</code>.
            </li>
          </ol>
          <p>(The <code>TypeRep</code> is gone now. It was just
            handy for debugging at the time.)</p>

          <p>Otherwise it's exactly the same, and in the year since I wrote the
            first version of Hell, this AST and the evaluator function have not
            changed at all. For me, this is an achievement. It's lovely to keep it so simple.</p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-22.png"><img src="slide-22.png"></a>
        <div>
          <p>
            Working backwards, an immediate question arises: how do you
            produce this quite strongly-typed AST from a completely
            untyped text input?
          </p>
          <p>Stephanie Weirich published a
            single <a href="https://www.cs.ox.ac.uk/projects/gip/school/tc.hs%3E">file</a>
            type checker implementation that addresses this problem
            neatly. It blew my mind that this was possible in Haskell
            so cleanly.</p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-23.png"><img src="slide-23.png"></a>
        <div>
          <p>
            The type signature essentially goes
            from <code>UTerm</code> (an untyped term) to a
            typed <code>Term</code> which has the type of the term as
            a parameter.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-24.png"><img src="slide-24.png"></a>
        <div>
          <p>The <code>UTerm</code> AST is a simple model of an AST that
            you might parse from a string. Note: there is
            a <code>UType</code> explicit type attached to the lambda
            that tells us what type the parameter is; your parser
            would parse e.g. <code>\(x::Bool) -&gt; ..</code> into this.</p>
          <p>In this example, <code>UType</code> is simply an "untyped" (meaning
            in the meta language doesn't have attached type
            information) type, which is either <code>Bool</code> or <code>Bool -&gt;
              Bool</code> etc.</p>
          <p>
            There's a familiar pattern here. Just like the evaluator
            seen above in Oleg's paper, the <code>Var</code> type
            gives us a variable reference whose scope is statically
            determined. Note the <code>Term (g,a)</code> in
            the <code>Lam</code> constructor; the <code>g</code>
            corresponds to the one in <code>Var g t</code>.
          </p>
          <p>The type-checkers job is to not only check that the types match up,
            but to build up this well-typed variable referencing.</p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-25.png"><img src="slide-25.png"></a>
        <div>
          <p>
            As for the <code>Ty</code> itself, it's a type-indexed equivalent of
            the <code>UType</code> type. The meta language (or host language) is
            using its own type system to mirror what's in the object
            language (or guest language). In the types as well as in
            term-level code.
          </p>
          <p>
            Here's how the <code>UType</code> becomes a <code>Ty
          t</code>. A handy existential is needed that'll be used in
          the type-checker called
<code>ExType</code> that just holds the result of the type-check.
          </p>
          <p>With these types in place, the typechecker for <code>UType -&gt;
            ExType</code> practically writes itself.</p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-26.png"><img src="slide-26.png"></a>
<div>
  <p>
    Turning to type-checking terms, type-checking an if requires an
    extra trick which is to compare that two types are equal and get a
    proof that they are so.  The
    <code>cmpTy</code> function starts with an <code>a</code> and <code>b</code> and by
    pattern-matching and aided by a handy GADT called <code>Equal</code> which
    essentially makes first class the ability to get both a
    value-level and type-level proof that <code>a ~ b</code>. There
    are shorter ways to do this, of course, but this is how it's done
    in this small example file.
  </p>
  <p>
    Finally, it can produce a convenient type
    called <code>Typed</code> that just couples up a thing with its
    type, as both the thing and the ty are indexed by the same
    thing. It locks in that relationship.
  </p>
</div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-27.png"><img src="slide-27.png"></a>
<div>
  <p>
    To both type-check and also scope-check a variable, there's need
    for an environment to keep track of those things in a typed lookup
    table while doing type-checking. It's like the stack earlier, but
    has a <code>String</code> in it to help build the correct de Bruijn index
    level based on the name. The more the <code>TyEnv</code> is walked, the more
    nested <code>Var</code> becomes.
  </p>
  <p>Type-checking a <code>UVar</code> then just becomes a lookup. (Imagine that
  the <code>error</code> calls are instead returning <code>Left</code>, but they were
    omitted for simplicity of the implementation.)</p>
  <p>Type-checking a lambda is more complicated and where the meat
  is:</p>
  <ol>
    <li>First, get a <code>Ty a</code> of the lambda's parameter type.</li>
    <li>Type-check the body <em>with the parameter in scope</em>.</li>
    <li>Construct an <code>a -&gt; b</code> type with <code>Arr</code> for the binder and
      the body.</li>
    <li>Finally, the <code>Lam</code> has enough type proofs in scope to be
      constructed.</li>
  </ol>
</div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-28.png"><img src="slide-28.png"></a>
        <div>
          <p>
            Comparatively, type-checking applications is easy. It's
            just a quick check that the function being applied is of
            type <code>a -&gt; b</code> and then that the argument is of type <code>a</code>.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-29.png"><img src="slide-29.png"></a>
        <div>
          <p>
            In review, this is the whole type checker. The example
            <code>main</code> shows how one might construct a basic untyped
            <code>UTerm</code> and then type-check it. The initial argument to
            <code>tc</code> is, unsurprisingly, <code>Nil</code> for the environment.
          </p>
          <p>That's it! Isn't that beautiful!</p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-30.png"><img src="slide-30.png"></a>
        <div>
          <p>
            Evaluating this AST is exactly the same as evaluating as
            seen above. This shows that you can type-check an untyped
            AST and then evaluate it with a total evaluator. Noice!
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-31.png"><img src="slide-31.png"></a>
        <div>
          <p>
            According
            to <a href="https://chrisdone.com/posts/three-questions-of-lang-design/">Three
            questions of language design</a>, it's not long before the
            question of how to do equality and ordering comes up. How
            do you compare strings, integers, etc? And how do you do
            things like sets and maps that require some kind of
            ordering.
          </p>
          <p>
            Haskell already has good answers for this:
            type-classes. For Hell, I didn't want to have to
            support <em>full</em> type-classes and all attendant
            features, but I equally didn't want to give up on
            including <code>Map</code> and <code>Set</code> or
            even <code>List.lookup</code>, and end up with <code>Int.eq</code>,
            <code>Text.eq</code>, etc.
          </p>
          <p>
            Luckily I discovered that Eitan Chatav had posted
            somewhere on
            reddit <a href="https://gist.github.com/chrisdone-artificial/8d807f6f26f08363a860330223591e70">an
            example</a> of exactly what I wanted to do, which was to
            infer based on known types type-class dictionaries for a
            few specific type-classes.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-32.png"><img src="slide-32.png"></a>
        <div>
          <p>
            In the term type, an actual class constraint can be added
            in there! Eitan's terms, types and <code>Ty</code>-equivalent are
            slightly different, but are otherwise identical.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-33.png"><img src="slide-33.png"></a>
        <div>
          <p>
            The trick here is simply to dispatch on the well-typed
            type-indexed GADT of <code>Type</code> and in that case one can
            "capture" the type-class instance dictionary and then the
            <code>T_Add</code> constructor is able to use that for its class
            constraint!
          </p>
          <p>
            This makes sense after you've seen it, but it blew my mind
            when I first saw it.
          </p>
          <p>
            This is <strong>not</strong> how how I did it in Hell, obviously;
            the <code>Term</code> type has no class constraints in it
            as seen above. But it gave me the key first step that I
            was able to evolve to what I needed.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-34.png"><img src="slide-34.png"></a>
        <div>
          <p>
            The <code>Ty</code> type defined earlier is fine, and the <code>Equal</code>
            utility, but it turns out Stephanie later made the
            <code>Type.Reflection</code> abstraction which replaces <code>Ty a</code> with
            <code>TypeRep a</code>, and provides equality, too. It can
            also deal with any Haskell type, of any kind.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-35.png"><img src="slide-35.png"></a>
        <div>
          <p>
            As a reminder, I showed that the <code>TypeRep (a ::
            Type)</code> is used in the <code>Term</code> type instead
            of the <code>Ty a</code> used in Stephanie's demo file
            that was much older.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-36.png"><img src="slide-36.png"></a>
        <div>
          <p>
            From <code>Type.Reflection</code> you've got a <code>TypeRep a</code> type, you
            can get a <code>TypeRep a</code> from any type that's an instance of
            <code>Typeable</code>, and can compare types for equality.
          </p>
          <p>
            Because any kind of type can be worked with, you often
            have to check that the kind is the one you expect before
            working with the type, so <code>typeRepKind</code> comes in handy
            there, too.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-37.png"><img src="slide-37.png"></a>
        <div>
          <p>
            Here's an example of how I wrote a trivial function to
            apply some unknown one type to another which is used in
            the inferer later on. There's a much better implementation
            later down the page, but this is fairly easy to read.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-38.png"><img src="slide-38.png"></a>
        <div>
          <p>
            Up to here I've covered a parser which yields
            <code>HSE.Exp</code> (the haskell-src-exts type) and I've described
            the <code>Term</code> AST that a type-checker is able to produce and
            an evaluator able to interpret. What's missing is the
            "untyped" term type, <code>UTerm</code>. Additionally, I
            want type inference, which is a step that should sit
            somewhere between parsing and final type-checking.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-39.png"><img src="slide-39.png"></a>
        <div>
          <p>
            Desugaring in Hell goes from <code>HSE.Exp HSE.SrcSpanInfo</code>
            (haskell-src-exts) to <code>UTerm ()</code>.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-40.png"><img src="slide-40.png"></a>
        <div>
          <p>
            The <code>UTerm</code> type now takes an extra parameter <code>t</code> in which
            I'll put <code>SomeTypeRep</code> - so it's similar to earlier, but
            I can now put other choices of type annotation in there.
          </p>
          <p>
            I use a handy type <code>SomeStarType</code> which just constrains
            the kind of the <code>a</code> in the <code>TypeRep a</code> to be <code>Type</code>
            (previously <code>*</code> in GHC); the type of regular
            values. You can see this concept in action in <code>toStarType</code>
            seen in the slide.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-41.png"><img src="slide-41.png"></a>
        <div>
        <p>I tried for a while with Hell to avoid type inference,
          because it can complicate everything. I don't need no
          stinkin' type inference! ... But after trying to write a real
          script in Hell, I realised that writing out the types of
          everything gets tedious really quickly.
        </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-42.png"><img src="slide-42.png"></a>
        <div>
          <p>
            When doing type inference, instead of working with
            <code>SomeTypeRep</code> as seen above, which has no concept
            of <em>variables</em>, I've defined <code>IRep</code>
            (<em>inference</em> type rep) for that. It has a type
            parameter for the representation of variables. While doing
            inference, it's going to be a little newtype wrapper
            around numbers called <code>IMetaVar</code>. When inference is
            finished, it'll be <code>Void</code>, ready for converting to
            <code>SomeTypeRep</code>.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-43.png"><img src="slide-43.png"></a>
        <div>
          <p>
            <code>inferExp</code>'s job is to make a <code>UTerm ()</code> into a <code>UTerm
            SomeTypeRep</code> -- if it can't do that, then there's either a
            type mismatch, an ambiguous type
            (<a href="https://stackoverflow.com/questions/31889048/what-does-the-ghc-source-mean-by-zonk">zonking</a>
            failed), or an infinite type. You can see in the
            implementation of <code>zonk</code> that it's just making sure that
            there are no type variables anymore.</p>
          <p>After that,
            <code>toSomeTypeRep</code> just converts
            our <code>IRep</code> tree into
            a <code>SomeTypeRep</code>. That can still fail if our
            type inferer has a bug. Unlikely, but it's not ruled out.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-44.png"><img src="slide-44.png"></a>
        <div>
          <p>
            A typical split in a type inferer is "elaborate, unify"
            which means first walk the AST and simply generate
            equality constraints like <code>f ~ a -> b</code>
            and <code>a ~ [Char]</code> and <code>b ~ Int</code>, and
            then the second part is to unify these constraints to get
            e.g. <code>[Char] -> Int</code>. It's a nice clean
            separation. Many industrial compilers will do these two
            phases in the same phase in the name of efficiency and the
            ability to generate new constraints on the fly, but I
            prefer the clean separation.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-45.png"><img src="slide-45.png"></a>
        <div>
          <p>
            <code>fromSomeStarType</code> produces an <code>IRep void</code> for the case
            that I know the type of something ahead of time, i.e. my
            primitives (<code>Int.plus</code>, etc.).
          </p>
          <p>
            On the right is a sample of elaborations of different
            parts of the AST. There isn't really anything in here
            that's out of the ordinary or that I'm excited to go into
            detail about.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-46.png"><img src="slide-46.png"></a>
        <div>
          <p>
            For unification, there's nothing new in here, either; it's
            very by the book. Given a set of equality constraints,
            generate a set of substitutions (replace these variables
            with these types). Afterwards, one can apply those
            substitutions to any type. In our case, that's all
            the <code>t</code> in <code>UTerm</code>.
          </p>
          <p>
            You can use off-the-shelf unification libraries like
            unification-fd or implement a mutable algorithm for extra
            speed, or use union-find, but this one fits on a page and
            does the job presently.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-47.png"><img src="slide-47.png"></a>
        <div>
          <p>
            Initially the AST had this for primitive terms:
          </p>
          <p><pre>ConBool :: Bool -> Term g Bool
ConString :: String -> Term g String</pre></p>
          <p>
            Which is fine if you want to enumerate every single type
            of value you want to be able to work with. I didn't want
            to do that. There's a way to make that shorter:
          </p>
          <p>
            <pre>Lit :: a -> Term g a
...
ULit (forall g. Typed (Term g))</pre>
          </p>
          <p>
            And then when you want to express e.g. <code>True</code> in the
            object language, you can just write a handy function like
            this that'll go straight from any <code>Typeable</code> into a
            <code>Typed</code>:
          </p>
          <p><pre>lit :: Type.Reflection.Typeable a => a -> UTerm
lit l = ULit (Typed (Type.Reflection.typeOf l) (Lit l))</pre></p>
          <p>The typechecker case is a no-op:</p>
          <p>
            <code>tc (ULit lit) _env = lit</code>
          </p>
          <p>
            And then simply <code>lit True</code> will work.
          </p>
          <p>So far so good, but what about polymorphic things? Like
            the function <code>id</code>? My solution was to make a newtype
            around a function, and that function accepted the type as
            an argument, just like in system F:</p>
          <p>
            <pre>newtype Forall =
  Forall (forall (a :: Type) g.
   TypeRep a -> Typed (Term g))
...
UForall SomeStarType Forall</pre>
          </p>
          <p>And in <code>UTerm</code>, carry a type and the forall together. So
          e.g. <code>id</code> would be represented like this:</p>
          <p>
<pre>id_ :: Forall
id_ = Forall (\a -> Typed (Type.Reflection.Fun a a) (Lit id))</pre></p>
          <p>I can then instantiate <code>id_</code> with whatever
          type I want, such as <code>Bool</code>:</p>
          <p>
            <pre>UForall (SomeStarType (Type.Reflection.typeRep @Bool)) id_</pre>
          </p>
          <p>It would merely be the type inferer's job to provide
            these type reps to the `UForall`, with the checker just
            applying the function:
          </p>
          <p><pre>tc (UForall (SomeStarType typeRep) (Forall f)) _env =
              f typeRep</pre>
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-48.png"><img src="slide-48.png"></a>
<div>
        <p>Since that initial discovery and implementing type
        inference, I changed <code>Forall</code> to be a GADT which represents a
        chain, so that it can be for example: <code>Eq a => Monad m => ...</code>
        </p>
        <p>Type inference adds a load of extra metadata to the
          <code>UForall</code> constructor, but the core idea is the
          same.</p>
</div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-49.png"><img src="slide-49.png"></a>
<div><p>
  The example of <code>id</code> hasn't changed very much, although here I'm
  using the <code>TypeRep</code> pattern to be able to bring the <code>a</code>
  type variable in directly. </p><p>In fact, I've since
  enabled any kind of type, so it becomes a full <code>SomeTypeRep</code> in
  <code>UForall</code>, in order to support records (which I'll show
  later) and their <code>Symbol</code> field names.</p></div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-50.png"><img src="slide-50.png"></a>
<div>
<p>
When type-checking these foralls, it's just a loop that successively
applies poly type arguments to functions that accept them. In the case
of type-classes like <code>OrdEqShow</code>, I use Eitan's trick of proving that
the type is e.g. one of <code>Int</code>, <code>Bool</code> etc. known types that support
<code>Ord</code>, <code>Eq</code> and <code>Show</code> and then simply continue applying the
arguments. Yes, this works, and yes, I was surprised. Even
higher-order kinded stuff like <code>Monad</code> had no trouble.
</p>
</div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-51.png"><img src="slide-51.png"></a>
<div>
<p>
Elaboration of foralls was straight-forward and this hasn't changed
since I made these slides. All I'm doing is generating a
meta-variable for each poly type in the <code>forall</code>, so <code>a</code>, <code>b</code>,
etc. Then I transform the type signature like <code>forall a. a -> a</code> that
is originally <code>IRep TH.Uniq</code> (template-haskell's way of
generating unique references) to <code>IRep IMetaVar</code>. Now I
can use it in the unifier.
</p><p>
The <code>types</code> variable represents any manually specified types like
<code>id @Int</code>, in which case we can emit an equality constraint on
the first poly type as <code>a ~ Int</code>.
</p></div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-52.png"><img src="slide-52.png"></a>
<div>
  <p>Primops that aren't polymorphic can all be defined via <code>lit</code>,
    like this.</p>
</div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-53.png"><img src="slide-53.png"></a>
<div>
  <p>As you saw above, writing out polymorphic prims
  like <code>id</code> is a bit boring and long. So i wrote some
  template-haskell to generate them for me based on a list like
  this. I won't go into the implementation because you can imagine
  it. Just generate the boilerplate.</p>
</div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-54.png"><img src="slide-54.png"></a>
<div>
  <p>The nice thing about using <code>TypeRep</code> is I didn't have to write
  much when listing out the supported types. I just specify their
  name and use <code>typeRep</code>. It doesn't matter what kind they
  are, which is quite nice.</p>
</div>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-55.png"><img src="slide-55.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-56.png"><img src="slide-56.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-57.png"><img src="slide-57.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-58.png"><img src="slide-58.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-59.png"><img src="slide-59.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-60.png"><img src="slide-60.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-61.png"><img src="slide-61.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-62.png"><img src="slide-62.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-63.png"><img src="slide-63.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-64.png"><img src="slide-64.png"></a>
      </div>
      <div class="slide">
        <a href="https://chrisdone.com/posts/tour-of-hell/slide-65.png"><img src="slide-65.png"></a>
      </div>
    </div>


</body></html>
