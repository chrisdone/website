<!doctype html>
<html>
  <head>
    <style>
      body {
          max-width: 60em;
          margin: .5in auto;
          font-size: 18px;
          font-family: serif;
          line-height: 1.5;
      }
      h1,h2,h3,h4,h5,h6 {
          font-family: Helvetica;
      }
      code { background: #eee; border: #aaa; border-radius: 3px;
             padding: 0.2em 0.5em }
      h1 a,h2 a,h3 a,h4 a {
          color: inherit;
      }
      @media(max-width:767px){
          body { margin: 1px 4px; }
          h1, h2, .menu { margin: 0; }
          h1 { font-size: 1.5em; }
          h2 { font-size: 1.125em; }
          h3 { font-size: 1.0125em; }
      }
      .slides { display: flex; flex-direction: column; row-gap: 2em }
      .slide { display: flex; flex-direction: row; column-gap: 2em; }
      .slide p, .slide li { line-height: 1.8em; text-align: justify; }
      .slide a {
          text-decoration: none;
      }
      .slide p a { text-decoration: underline }
      .slide img {
          width: 20em; border: 1px solid #ddd; border-radius: 3px;
          box-shadow: 0.1em 0.1em 0.1em 0.1em rgba(100, 100, 100, .1);
      }
      .slide p:first-child {
          margin-top: 0;
      }
      .date { margin-bottom: 2em; padding-top: 0em; }
    </style>
  </head>
  <body>
    <h1>A Tour of Hell</h1>
    <p class="date"><em>Feb 9th 2024</em></p>
    <div class="slides">
      <div class="slide">
        <a href="slide-9.png"><img src="slide-9.png"></a>
        <div>
          <p>This set of slides sketches out the solution, as an
            implementation, in technical detail.</p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-11.png"><img src="slide-11.png"></a>
        <div>
          <p>There are a few limits on the language; no imports, no
            polymorphism (poly types) i.e. no declaration is ever
            inferred with a <code>forall a.</code> in it. Poly types are
            awesome, but they make the implementation harder, and are a
            form of abstraction that you might not need in a scripting
            language. I don't need them in my case, YMMV.
          </p>
          <p>
            No imports: instead, all names that usually come under a
            package name like <code>async</code>
            become <code>Async.race</code>, <code>List.map</code>,
            etc. All identifiers are explicitly qualified except
            lambda parameters: <code>\x -> x</code> -- not qualified.
          </p>
          <p>
            Recursion is completely ruled out, but <code>fix</code>
            works fine, so you still have it as a primitive
            function. It's just not something you can produce
            yourself.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-15.png"><img src="slide-15.png"></a>
        <div>
          <p>
            Rather than bothering to implement a parser, I used
            haskell-src-exts. That package isn't really maintained
            anymore, but I'm kind of used to it now, and GHC's parser is
            a bit too wordy for me.
          </p>
          <p>
            Re-using a parser is usually wise, parsing layout in Haskell
            is fiddly and I just wanted something that works as I'm used
            to.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-16.png"><img src="slide-16.png"></a>
        <div>
          <p>
            The next step is to desugar this syntax into something
            smaller. <code>do</code>-notation becomes
            nested <code>>>=</code> calls, etc.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-17.png"><img src="slide-17.png"></a>
        <div>
          <p>
            Parsing is the beginning of the pipeline. For this
            project, a primary concern was to make the evaluator as
            lean as possible, and, ideally,
            <a href="https://en.wikipedia.org/wiki/Partial_function">total</a>
            and complete. With this in mind, I started at the
            interpreter and worked backwards from there. What does a
            trivial but total evaluator look like in Haskell?
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-18.png"><img src="slide-18.png"></a>
        <div>
          <p>
            Here's a basic one. It's called "higher-order abstract
            syntax" because you've got syntax productions that take
            functions as arguments. Rather than carrying an
            environment around, like in,
            e.g. <a href="https://norvig.com/lispy.html">How to Write
              a (Lisp) Interpreter (in Python)</a>, you store a
            function <em>as a real function</em>. When you pass an
            environment around, you tend to have a lookup function
            that could throw an error if you got your evaluator wrong.
          </p>
          <p>
            This evaluator is <em>total</em> and won't crash. This is
            really neat and tidy. The only downside really is that
            it's opaque. It's hard to work with functions, because you
            can't look inside them once you've made them. You also
            can't smooth out the wrinkles inside them, at least, as
            far as I'm aware. I've heard of cunning approaches to do
            so, but some things are best left alone.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-19.png"><img src="slide-19.png"></a>
        <div>
          <p>
            I encountered another approach while perusing Oleg
            Kiselyov's
            <a href="https://okmij.org/ftp/tagless-final/course/lecture.pdf"><em>Typed Tagless Final Interpreters</em></a> paper and he dropped in
            this example like it was the most normal thing in the
            world. I'm not sure where Oleg got this from.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-20.png"><img src="slide-20.png"></a>

        <div>
          <p>
            This evaluator is not higher order. It features environment lookup and
            the evaluator carries around an environment. But there's something
            clever here: that lookup will always succeed.
          </p>
          <p>
            The environment is a simple stack of tuples. When
            evaluating a lambda, simply wrap the environment in
            another tuple with the argument being passed.
          </p>
          <p>
            Variables are church numerals: 0 is <code>VZ</code>, 1
            is <code>VS VZ</code>, 2 is <code>VS (VS VZ)</code>, etc.
            It's
            a <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de
            Bruijn index</a> that is statically typed. It means "how
            far up the stack do you go?" Lookup simply walks both the
            church numeral and the environment until the zero case
            (<code>VZ</code>) is reached, and then what's there in the
            stack is returned.
          </p>
          <p>
            The way to make this total and guaranteed to be correct is via the
            <code>env</code> type parameter that both the <code>Exp</code> type and the <code>Var</code> type
            share.
            It took me a few readings to believe that this actually works. It's
            beautiful.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-21.png"><img src="slide-21.png"></a>
        <div>
          <p>Hell's core AST and evaluator are almost identical, with a couple
            adjustments.</p>

          <ol>
            <li>Oleg's example hard-codes Bool just for demonstration
              purposes. Hell's AST has <code>Lit</code> instead, which can produce any
              <code>a</code>. All primitive functions e.g. <code>List.map</code> or e.g. literals like
              <code>123</code> are kept in there.</li>
            <li>
              In the zero case for <code>Var</code>, Hell keeps a function as a final
              accessor function. This lets us easily pull out a tuple slot from a
              function argument, e.g. <code>\(x,y) -> x</code> becomes, conceptually, <code>\xy
                -> fst x</code>. This could later possibly be used for e.g. <code>\X{x,y} ->
                x</code>.
            </li>
          </ol>
          <p>(The <code>TypeRep</code> is gone now. It was just
            handy for debugging at the time.)</p>

          <p>Otherwise it's exactly the same, and in the year since I wrote the
            first version of Hell, this AST and the evaluator function have not
            changed at all. For me, this is an achievement. It's lovely to keep it so simple.</p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-22.png"><img src="slide-22.png"></a>
        <div>
          <p>
            Working backwards, an immediate question arises: how do you
            produce this quite strongly-typed AST from a completely
            untyped text input?
          </p>
          <p>Stephanie Weirich published a
            single <a href="https://www.cs.ox.ac.uk/projects/gip/school/tc.hs>">file</a>
            type checker implementation that addresses this problem
            neatly. It blew my mind that this was possible in Haskell
            so cleanly.</p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-23.png"><img src="slide-23.png"></a>
        <div>
          <p>
            The type signature essentially goes
            from <code>UTerm</code> (an untyped term) to a
            typed <code>Term</code> which has the type of the term as
            a parameter.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-24.png"><img src="slide-24.png"></a>
        <div>
          <p>The <code>UTerm</code> AST is a simple model of an AST that
            you might parse from a string. Note: there is
            a <code>UType</code> explicit type attached to the lambda
            that tells us what type the parameter is; your parser
            would parse e.g. <code>\(x::Bool) -> ..</code> into this.</p>
          <p>In this example, <code>UType</code> is simply an "untyped" (meaning
            in the meta language doesn't have attached type
            information) type, which is either <code>Bool</code> or <code>Bool ->
              Bool</code> etc.</p>
          <p>
            There's a familiar pattern here. Just like the evaluator
            seen above in Oleg's paper, the <code>Var</code> type
            gives us a variable reference whose scope is statically
            determined. Note the <code>Term (g,a)</code> in
            the <code>Lam</code> constructor; the <code>g</code>
            corresponds to the one in <code>Var g t</code>.
          </p>
          <p>The type-checkers job is to not only check that the types match up,
            but to build up this well-typed variable referencing.</p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-25.png"><img src="slide-25.png"></a>
        <div>
          <p>
            As for the <code>Ty</code> itself, it's a type-indexed equivalent of
            the <code>UType</code> type. The meta language (or host language) is
            using its own type system to mirror what's in the object
            language (or guest language). In the types as well as in
            term-level code.
          </p>
          <p>
            Here's how the <code>UType</code> becomes a <code>Ty
          t</code>. A handy existential is needed that'll be used in
          the type-checker called
<code>ExType</code> that just holds the result of the type-check.
          </p>
          <p>With these types in place, the typechecker for <code>UType ->
            ExType</code> practically writes itself.</p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-26.png"><img src="slide-26.png"></a>
<div>
  <p>
    Turning to type-checking terms, type-checking an if requires an
    extra trick which is to compare that two types are equal and get a
    proof that they are so.  The
    <code>cmpTy</code> function starts with an <code>a</code> and <code>b</code> and by
    pattern-matching and aided by a handy GADT called <code>Equal</code> which
    essentially makes first class the ability to get both a
    value-level and type-level proof that <code>a ~ b</code>. There
    are shorter ways to do this, of course, but this is how it's done
    in this small example file.
  </p>
  <p>
    Finally, it can produce a convenient type
    called <code>Typed</code> that just couples up a thing with its
    type, as both the thing and the ty are indexed by the same
    thing. It locks in that relationship.
  </p>
</div>
      </div>
      <div class="slide">
        <a href="slide-27.png"><img src="slide-27.png"></a>
<div>
  <p>
    To both type-check and also scope-check a variable, there's need
    for an environment to keep track of those things in a typed lookup
    table while doing type-checking. It's like the stack earlier, but
    has a <code>String</code> in it to help build the correct de Bruijn index
    level based on the name. The more the <code>TyEnv</code> is walked, the more
    nested <code>Var</code> becomes.
  </p>
  <p>Type-checking a <code>UVar</code> then just becomes a lookup. (Imagine that
  the <code>error</code> calls are instead returning <code>Left</code>, but they were
    omitted for simplicity of the implementation.)</p>
  <p>Type-checking a lambda is more complicated and where the meat
  is:</p>
  <ol>
    <li>First, get a <code>Ty a</code> of the lambda's parameter type.</li>
    <li>Type-check the body <em>with the parameter in scope</em>.</li>
    <li>We construct an <code>a -> b</code> type with <code>Arr</code> for the binder and
      the body.</li>
    <li>Finally, the <code>Lam</code> has enough type proofs in scope to be
      constructed.</li>
  </ol>
</div>
      </div>
      <div class="slide">
        <a href="slide-28.png"><img src="slide-28.png"></a>
        <div>
          <p>
            Comparatively, type-checking applications is easy. It's
            just a quick check that the function being applied is of
            type <code>a -> b</code> and then that the argument is of type <code>a</code>.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-29.png"><img src="slide-29.png"></a>
        <div>
          <p>
            In review, this is the whole type checker. The example
            <code>main</code> shows how one might construct a basic untyped
            <code>UTerm</code> and then type-check it. The initial argument to
            <code>tc</code> is, unsurprisingly, <code>Nil</code> for the environment.
          </p>
          <p>That's it! Isn't that beautiful!</p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-30.png"><img src="slide-30.png"></a>
        <div>
          <p>
            Evaluating this AST is exactly the same as evaluating as
            we saw above. We now know that we can type-check an
            untyped AST and then evaluate it with a total
            evaluator. Noice!
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-31.png"><img src="slide-31.png"></a>
        <div>
          <p>
            According
            to <a href="https://chrisdone.com/posts/three-questions-of-lang-design/">Three
            questions of language design</a>, it's not long before the
            question of how to do equality and ordering comes up. How
            do we compare strings, integers, etc? And how do we do
            things like sets and maps that require some kind of
            ordering.
          </p>
          <p>
            Haskell already has good answers for this:
            type-classes. For Hell, I didn't want to have to
            support <em>full</em> type-classes and all attendant
            features, but I equally didn't want to give up on
            including <code>Map</code> and <code>Set</code> or
            even <code>List.lookup</code>, and end up with <code>Int.eq</code>,
            <code>Text.eq</code>, etc.
          </p>
          <p>
            Luckily I discovered that Eitan Chatav had posted
            somewhere on reddit an example of exactly what I wanted to
            do, which was to infer based on known types type-class
            dictionaries for a few specific type-classes.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-32.png"><img src="slide-32.png"></a>
        <div>
          <p>
            In the term type, an actual class constraint can be added
            in there! Eitan's terms, types and <code>Ty</code>-equivalent are
            slightly different, but are otherwise identical.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-33.png"><img src="slide-33.png"></a>
        <div>
          <p>
            The trick here is simply to dispatch on the well-typed
            type-indexed GADT of <code>Type</code> and in that case one can
            "capture" the type-class instance dictionary and then the
            <code>T_Add</code> constructor is able to use that for its class
            constraint!
          </p>
          <p>
            This makes sense after you've seen it, but it blew my mind
            when I first saw it.
          </p>
          <p>
            This is how how I did it in Hell, obviously; the `Term`
            type has no class constraints in it as seen above. But it
            gave me the key first step that I was able to evolve to
            what I needed.
          </p>
        </div>
      </div>
      <div class="slide">
        <a href="slide-34.png"><img src="slide-34.png"></a>
      </div>
      <div class="slide">
        <a href="slide-35.png"><img src="slide-35.png"></a>
      </div>
      <div class="slide">
        <a href="slide-36.png"><img src="slide-36.png"></a>
      </div>
      <div class="slide">
        <a href="slide-37.png"><img src="slide-37.png"></a>
      </div>
      <div class="slide">
        <a href="slide-38.png"><img src="slide-38.png"></a>
      </div>
      <div class="slide">
        <a href="slide-39.png"><img src="slide-39.png"></a>
      </div>
      <div class="slide">
        <a href="slide-40.png"><img src="slide-40.png"></a>
      </div>
      <div class="slide">
        <a href="slide-41.png"><img src="slide-41.png"></a>
      </div>
      <div class="slide">
        <a href="slide-42.png"><img src="slide-42.png"></a>
      </div>
      <div class="slide">
        <a href="slide-43.png"><img src="slide-43.png"></a>
      </div>
      <div class="slide">
        <a href="slide-44.png"><img src="slide-44.png"></a>
      </div>
      <div class="slide">
        <a href="slide-45.png"><img src="slide-45.png"></a>
      </div>
      <div class="slide">
        <a href="slide-46.png"><img src="slide-46.png"></a>
      </div>
      <div class="slide">
        <a href="slide-47.png"><img src="slide-47.png"></a>
      </div>
      <div class="slide">
        <a href="slide-48.png"><img src="slide-48.png"></a>
      </div>
      <div class="slide">
        <a href="slide-49.png"><img src="slide-49.png"></a>
      </div>
      <div class="slide">
        <a href="slide-50.png"><img src="slide-50.png"></a>
      </div>
      <div class="slide">
        <a href="slide-51.png"><img src="slide-51.png"></a>
      </div>
      <div class="slide">
        <a href="slide-52.png"><img src="slide-52.png"></a>
      </div>
      <div class="slide">
        <a href="slide-53.png"><img src="slide-53.png"></a>
      </div>
      <div class="slide">
        <a href="slide-54.png"><img src="slide-54.png"></a>
      </div>
      <div class="slide">
        <a href="slide-55.png"><img src="slide-55.png"></a>
      </div>
      <div class="slide">
        <a href="slide-56.png"><img src="slide-56.png"></a>
      </div>
      <div class="slide">
        <a href="slide-57.png"><img src="slide-57.png"></a>
      </div>
      <div class="slide">
        <a href="slide-58.png"><img src="slide-58.png"></a>
      </div>
      <div class="slide">
        <a href="slide-59.png"><img src="slide-59.png"></a>
      </div>
      <div class="slide">
        <a href="slide-60.png"><img src="slide-60.png"></a>
      </div>
      <div class="slide">
        <a href="slide-61.png"><img src="slide-61.png"></a>
      </div>
      <div class="slide">
        <a href="slide-62.png"><img src="slide-62.png"></a>
      </div>
      <div class="slide">
        <a href="slide-63.png"><img src="slide-63.png"></a>
      </div>
      <div class="slide">
        <a href="slide-64.png"><img src="slide-64.png"></a>
      </div>
      <div class="slide">
        <a href="slide-65.png"><img src="slide-65.png"></a>
      </div>
    </div>
  </body>
</html>
