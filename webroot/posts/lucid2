<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Lucid 2.0: clearer than before</title>
  <style>body {
  max-width: 40em;
  margin: .5in auto;
  font-size: 18px;
  font-family: serif;
  margin-top: 5em;
  line-height: 1.5;
}
pre, code {
  font-size: 16px;
}
pre {
  margin-left: 1.5em;
  line-height: 1.2;
}
a {
  color: #1a6e8e
}
.menu a {
  margin-right: 1em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Helvetica;
}

h1 a,h2 a,h3 a,h4 a {
  text-decoration: none;
  color: inherit;
}

.post-1,.post-2{
  margin-bottom: 0.5em;
}

.author {
  display: none;
}

footer {
  margin-top: 1.5em;
  padding-top: 1.5em;
  border-top: 1px solid #ccc;
  margin-bottom: 2em
}

footer span {
  display: none;
}

img {
  max-width: 100%
}
pre.sourceCode span.st {
  color: #366354
}
pre.sourceCode span.kw {
  color: #397460
}
pre.sourceCode span.fu {
  color: #8f4e8b
}
pre.sourceCode span.ot {
  color: #2e659c
}
pre.sourceCode span.dt {
  color: #4F4371
}
pre.sourceCode span.co {
  color: #666
}
  </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>Lucid 2.0: clearer than before</h1>
<p class="author">By <a href="https://chrisdone.com/">Chris Done</a></p>

<p>Since <a href="https://chrisdone.com/posts/lucid">my last post</a> about Lucid, I’ve <a href="http://hackage.haskell.org/package/lucid">updated Lucid to major version 2.0</a> in a way that removes the need for the <code>with</code> combinator. Now, you can just write:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">term_ <span class="fu">&lt;</span>children<span class="fu">&gt;</span>
term_ [<span class="fu">&lt;</span>props<span class="fu">&gt;</span>] <span class="fu">&lt;</span>children<span class="fu">&gt;</span></code></pre>
<p>Example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">page ::</span> <span class="dt">Html</span> ()
page <span class="fu">=</span>
  html_
    (<span class="kw">do</span> head_
          (<span class="kw">do</span> title_ <span class="st">&quot;Introduction page.&quot;</span>
              link_ [rel_ <span class="st">&quot;stylesheet&quot;</span>,type_ <span class="st">&quot;text/css&quot;</span>,href_ <span class="st">&quot;screen.css&quot;</span>]
              style_ <span class="st">&quot;body{background:red}&quot;</span>)
        body_
          (<span class="kw">do</span> div_ [id_ <span class="st">&quot;header&quot;</span>,style_ <span class="st">&quot;color:white&quot;</span>] <span class="st">&quot;Syntax&quot;</span>
              p_ (span_ (strong_ <span class="st">&quot;This is an example of Lucid syntax.&quot;</span>))
              hr_ []
              ul_ (mapM_ (li_ <span class="fu">.</span> toHtml <span class="fu">.</span> show)
                         [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])
              table_ (tr_ (<span class="kw">do</span> td_ <span class="st">&quot;Hello!&quot;</span>
                              td_ [class_ <span class="st">&quot;alt&quot;</span>] <span class="st">&quot;World!&quot;</span>
                              td_ <span class="st">&quot;Sup?&quot;</span>))))</code></pre>
<p>Here’s the (pretty printed) output:</p>
<pre class="sourceCode html"><code class="sourceCode html">λ&gt; page
<span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span>
<span class="kw">&lt;html&gt;</span>
<span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span>Introduction page.<span class="kw">&lt;/title&gt;</span>
    <span class="kw">&lt;link</span><span class="ot"> href=</span><span class="st">&quot;screen.css&quot;</span><span class="ot"> rel=</span><span class="st">&quot;stylesheet&quot;</span><span class="ot"> type=</span><span class="st">&quot;text/css&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;style&gt;</span>body<span class="kw">{background:</span><span class="dt">red</span><span class="kw">}&lt;/style&gt;</span>
<span class="kw">&lt;/head&gt;</span>
<span class="kw">&lt;body&gt;</span>
    <span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;header&quot;</span><span class="ot"> style=</span><span class="st">&quot;color:white&quot;</span><span class="kw">&gt;</span>Syntax<span class="kw">&lt;/div&gt;</span>
    <span class="kw">&lt;p&gt;&lt;span&gt;&lt;strong&gt;</span>This is an example of Lucid syntax.<span class="kw">&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;</span>
    <span class="kw">&lt;hr&gt;</span>
    <span class="kw">&lt;ul&gt;</span>
        <span class="kw">&lt;li&gt;</span>1<span class="kw">&lt;/li&gt;</span>
        <span class="kw">&lt;li&gt;</span>2<span class="kw">&lt;/li&gt;</span>
        <span class="kw">&lt;li&gt;</span>3<span class="kw">&lt;/li&gt;</span>
    <span class="kw">&lt;/ul&gt;</span>
    <span class="kw">&lt;table&gt;</span>
        <span class="kw">&lt;tr&gt;</span>
            <span class="kw">&lt;td&gt;</span>Hello!<span class="kw">&lt;/td&gt;</span>
            <span class="kw">&lt;td</span><span class="ot"> class=</span><span class="st">&quot;alt&quot;</span><span class="kw">&gt;</span>World!<span class="kw">&lt;/td&gt;</span>
            <span class="kw">&lt;td&gt;</span>Sup?<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;/tr&gt;</span>
    <span class="kw">&lt;/table&gt;</span>
<span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<h2 id="overloaded">Overloaded</h2>
<p>Element terms are now typed like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">p_ ::</span> <span class="dt">Term</span> arg result <span class="ot">=&gt;</span> arg <span class="ot">-&gt;</span> result</code></pre>
<p>Giving a couple overloaded instances:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">p_ ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m () <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m ()
<span class="ot">p_ ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">HtmlT</span> m () <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m ()</code></pre>
<p>This is similar to the variadic <code>printf</code> from <code>Text.Printf</code>, but limited to one level of variance.</p>
<h1 id="retaining-old-invariants">Retaining old invariants</h1>
<p>In <a href="https://chrisdone.com/posts/lucid">my last post I listed</a> a bunch of factors that Lucid should solve, I worked hard to make sure these were met in this change.</p>
<h2 id="preserving-liberal-term-use">Preserving liberal term use</h2>
<p>You can still use <code>style_</code> or <code>title_</code> as an element or an attribute:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; style_ [style_ <span class="st">&quot;inception&quot;</span>] <span class="st">&quot;Go deeper.&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="fu">&lt;</span>style style<span class="fu">=</span><span class="st">&quot;inception&quot;</span><span class="fu">&gt;</span><span class="dt">Go</span> deeper<span class="fu">.&lt;/</span>style<span class="fu">&gt;</span></code></pre>
<h2 id="preserving-encoding-properties">Preserving encoding properties</h2>
<p>The <code>script_</code> and <code>style_</code> elements still output unencoded:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; script_ <span class="st">&quot;alert('Hello!' &gt; 12)&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="fu">&lt;</span>script<span class="fu">&gt;</span>alert(<span class="ch">'Hello!'</span> <span class="fu">&gt;</span> <span class="dv">12</span>)<span class="fu">&lt;/</span>script<span class="fu">&gt;</span></code></pre>
<h2 id="with-is-still-available">With is still available</h2>
<p>You can still add attributes to elements using <code>with</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; p_ [id_ <span class="st">&quot;foo&quot;</span>] <span class="st">&quot;&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="fu">&lt;</span>p id<span class="fu">=</span><span class="st">&quot;foo&quot;</span><span class="fu">&gt;&lt;/</span>p<span class="fu">&gt;</span>
λ&gt; with (p_ [id_ <span class="st">&quot;foo&quot;</span>]) [class_ <span class="st">&quot;red&quot;</span>] <span class="st">&quot;yo&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="fu">&lt;</span>p id<span class="fu">=</span><span class="st">&quot;foo&quot;</span> <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;red&quot;</span><span class="fu">&gt;</span>yo<span class="fu">&lt;/</span>p<span class="fu">&gt;</span></code></pre>
<h2 id="convenient-construction-of-custom-elements">Convenient construction of custom elements</h2>
<p>You can construct custom elements if needed:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; with (term <span class="st">&quot;potato&quot;</span> [id_ <span class="st">&quot;foo&quot;</span>]) [class_ <span class="st">&quot;red&quot;</span>] <span class="st">&quot;yo&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="fu">&lt;</span>potato id<span class="fu">=</span><span class="st">&quot;foo&quot;</span> <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;red&quot;</span><span class="fu">&gt;</span>yo<span class="fu">&lt;/</span>potato<span class="fu">&gt;</span></code></pre>
<p>But you can also construct normal elements with a custom class, so that you don’t have to use <code>with</code> for extending elements like our old <code>container_</code> example, you can construct an element with some given attributes:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">let</span> container_ <span class="fu">=</span> termWith <span class="st">&quot;div&quot;</span> [class_ <span class="st">&quot; container &quot;</span>]</code></pre>
<p>And then use it later like a normal element:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; container_ [class_ <span class="st">&quot;main&quot;</span>] <span class="st">&quot;OK, go!&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="fu">&lt;</span>div <span class="kw">class</span><span class="fu">=</span><span class="st">&quot; container main&quot;</span><span class="fu">&gt;</span><span class="dt">OK</span>, go<span class="fu">!&lt;/</span>div<span class="fu">&gt;</span></code></pre>
<p>Some basic Bootstrap terms are available in <a href="https://hackage.haskell.org/package/lucid-2.1/docs/Lucid-Bootstrap.html">Lucid.Bootstrap</a>.</p>
<h2 id="still-a-monad-transformer">Still a monad transformer</h2>
<p>I didn’t change anything about the monad itself. Just the combinators. So you can still use it as a transformer:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; runReader (renderTextT (html_ (body_ (<span class="kw">do</span> name <span class="ot">&lt;-</span> lift ask
                                            p_ [class_ <span class="st">&quot;name&quot;</span>] (toHtml name)))))
             (<span class="st">&quot;Chris&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)
<span class="st">&quot;&lt;html&gt;&lt;body&gt;&lt;p class=\&quot;name\&quot;&gt;Chris&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span></code></pre>
<h2 id="small-trade-off">Small trade-off</h2>
<p>One small difference is that elements that take no children always take arguments:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | @input@ element</span>
<span class="ot">input_ ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m ()
input_ <span class="fu">=</span> with (makeElementNoEnd <span class="st">&quot;input&quot;</span>)</code></pre>
<p>So you will always write:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">input_ [<span class="fu">&lt;</span>something<span class="fu">&gt;</span>]</code></pre>
<p>But in practice it seems that elements with no children almost always take a number of attributes. Exceptions to that rule are <code>br_</code> and <code>hr_</code>, but those are quite rare. So this is a very happy trade-off, I feel. (See the ‘real examples’ at the end of this post.)</p>
<p>Extending elements like this is straight-forward using our usual <code>with</code> combinator. Example, suppose you’re sick of writing the classic <code>input type=&quot;text&quot;</code>, you can define a combinator like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">text_ ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m ()
text_ <span class="fu">=</span> with (with (makeElementNoEnd <span class="st">&quot;input&quot;</span>) [type_ <span class="st">&quot;text&quot;</span>])</code></pre>
<p>And now you can write:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; text_ []
<span class="fu">&lt;</span>input <span class="kw">type</span><span class="fu">=</span><span class="st">&quot;text&quot;</span><span class="fu">&gt;</span>
λ&gt; text_ [class_ <span class="st">&quot;foo&quot;</span>]
<span class="fu">&lt;</span>input <span class="kw">type</span><span class="fu">=</span><span class="st">&quot;text&quot;</span> <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;foo&quot;</span><span class="fu">&gt;</span></code></pre>
<h2 id="larger-trade-off">Larger trade-off</h2>
<p>Due to the overloadedness, similar to the overloaded strings example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="st">&quot;foo &gt; bar&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
foo <span class="fu">&amp;</span>gt; bar</code></pre>
<p>You have to use a type annotation in GHCi:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; p_ <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="fu">&lt;</span>p<span class="fu">&gt;</span>foo<span class="fu">&lt;/</span>p<span class="fu">&gt;</span></code></pre>
<p>Otherwise you get</p>
<blockquote>
<p>No instance for <code>(Term arg0 a0)</code> arising from a use of <code>it</code></p>
</blockquote>
<p>Most Haskellers won’t care about this case, but for GHCi users it’s a slight regression. Also, in some local where declarations, you might need a type signature. For example, the following is OK:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">people ::</span> <span class="dt">Html</span> ()
people <span class="fu">=</span> ul_ (mapM_ person [<span class="st">&quot;Mary Smith&quot;</span>,<span class="st">&quot;Dave Jones&quot;</span>])
  <span class="kw">where</span> person name <span class="fu">=</span> li_ name</code></pre>
<p>Whereas in this case:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bigTable ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Html</span> ()
bigTable t <span class="fu">=</span> table_ (mapM_ row t)
  <span class="kw">where</span> row r <span class="fu">=</span> tr_ (mapM_ (td_ <span class="fu">.</span> toHtml <span class="fu">.</span> show) r)</code></pre>
<p>It’s a little harder for GHC to infer this, so you add a type-signature:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bigTable ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Html</span> ()
bigTable t <span class="fu">=</span> table_ (mapM_ row t)
  <span class="kw">where</span><span class="ot"> row ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span> ()
        row r <span class="fu">=</span> tr_ (mapM_ (td_ <span class="fu">.</span> toHtml <span class="fu">.</span> show) r)</code></pre>
<p>Not a big deal given the benefits, but something to be aware of.</p>
<h2 id="summary">Summary</h2>
<p>In total, I’ve made this library almost perfect for my own tastes. It’s concise, easy to read and edit (and auto-format), it lacks namespace issues, it’s easy to make re-usable terms, and it’s fast enough. The need for the <code>with</code> combinator was the only wart that naggled me over the past week, I knew I’d end up making some change. I’ve also covered the trade-offs that come with this design decision.</p>
<p>As far as I’m concerned, Lucid can rest at major version <code>2.*</code> for a long time now. I added some newfangled HTML5 elements (who knew <code>main</code> was now an element?) and <a href="https://github.com/chrisdone/lucid/blob/master/test/Main.hs">a test suite</a>. You can expect the only minor version bumps henceforth to be bugfixes, regression tests, and more documentation.</p>
<p>For some real examples:</p>
<ul>
<li><a href="https://github.com/chrisdone/tryhaskell/blob/d8b59e71d46cb890935f5c0c6c1d723cc9f78d99/src/TryHaskell.hs#L326-L419">Try Haskell</a> is now using Lucid.</li>
<li>As is the upcoming <a href="https://github.com/haskell-infra/hl/blob/master/src/HL/V/Template.hs#L37-171">Haskell homepage</a>.</li>
<li>And <a href="https://github.com/relrod/isysuclosed.com/blob/haskell/Main.hs#L34">isysuclosed.com</a>.</li>
</ul>

<footer>
  © 2014-11-20 Chris Done &lt;chrisdone@gmail.com&gt;
<span style="float:right"><a href="../rss.xml">RSS</a></span>
</footer>

    </div>

  </body>
</html>
