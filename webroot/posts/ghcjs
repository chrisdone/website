<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Experimenting with GHCJS, the Haskell→JavaScript compiler</title>
  <style>body {
  max-width: 40em;
  margin: .5in auto;
  font-size: 18px;
  font-family: serif;
  margin-top: 5em;
  line-height: 1.5;
}
pre, code {
  font-size: 16px;
}
pre {
  margin-left: 1.5em;
  line-height: 1.2;
}
a {
  color: #1a6e8e
}
.menu a {
  margin-right: 1em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Helvetica;
}

h1 a,h2 a,h3 a,h4 a {
  text-decoration: none;
  color: inherit;
}

.post-1,.post-2{
  margin-bottom: 0.5em;
}

.author {
  display: none;
}

footer {
  margin-top: 1.5em;
  padding-top: 1.5em;
  border-top: 1px solid #ccc;
  margin-bottom: 2em
}

footer span {
  display: none;
}

img {
  max-width: 100%
}
pre.sourceCode span.st {
  color: #366354
}
pre.sourceCode span.kw {
  color: #397460
}
pre.sourceCode span.fu {
  color: #8f4e8b
}
pre.sourceCode span.ot {
  color: #2e659c
}
pre.sourceCode span.dt {
  color: #4F4371
}
pre.sourceCode span.co {
  color: #666
}
  </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>Experimenting with GHCJS, the Haskell→JavaScript compiler</h1>
<p class="author">By <a href="https://chrisdone.com/">Chris Done</a></p>

<!-- Part 1: Explain what's wrong with JavaScript -->

<p>JavaScript <em>per se</em> is insufficient. The depths to which JavaScript fails is well-documented and well-understood. Its main faults are its verbose function syntax<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>, late binding<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup>, which has led to the creation of various static analysis tools to alleviate this language flaw<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup>, but with limited success<sup><a href="#fn4" class="footnoteRef" id="fnref4">4</a></sup> (there is even a static type checker<sup><a href="#fn5" class="footnoteRef" id="fnref5">5</a></sup>), <a href="https://stackoverflow.com/questions/5447153/javascript-equality-transitivity-is-weird/5447170#5447170">finicky equality</a>, <code>this</code> behaviour, and lack of static types and modules<sup><a href="#fn6" class="footnoteRef" id="fnref6">6</a></sup>.</p>
<!-- Part 2: Explain the ways in which we fix JavaScript -->

<p>Using JavaScript for what it is good for<sup><a href="#fn7" class="footnoteRef" id="fnref7">7</a></sup>, but not using the language <em>per se</em>, is therefore desirable, and many are working to achieve this<sup><a href="#fn8" class="footnoteRef" id="fnref8">8</a></sup>, in some form or another. There various ways to do it<sup><a href="#fn9" class="footnoteRef" id="fnref9">9</a></sup>, but I will opt for compiling an existing language, Haskell, to JavaScript, because I do not have time to learn or teach other people a new language, garner a new library set and a new type checker and all that Haskell implementations provide.</p>
<!-- Part 3: Explain compiler choice -->

<p>Given the option, I’d choose <a href="https://www.haskell.org/ghc/">GHC</a> because it is the flagship Haskell compiler, with <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html">the most features</a>, which most Haskellers write all their projects with. Haskell has a standard, <a href="http://www.haskell.org/pipermail/haskell/2009-November/021750.html">presently Haskell 2010</a>, but I think that most projects out there use quite a few language extensions<sup><a href="#fn10" class="footnoteRef" id="fnref10">10</a></sup> outside of the standard; Haskellers target GHC. This is not to say that for compiling to JS, Haskell 98 wouldn’t be a vast improvement.</p>
<!-- Part 4: Introduce GHCJS -->

<p>Fortunately there is a project maintained by <a href="https://asviraspossible.livejournal.com/">Victor Nazarov</a> called <a href="https://github.com/sviperll/ghcjs">GHCJS</a>. You can use GHC 6.12.3 or GHC 7+. For my experimentation I am using 6.12.3. I followed <a href="https://github.com/sviperll/ghcjs/blob/master/README.markdown">the instructions given</a>, with a fix for the build process<sup><a href="#fn11" class="footnoteRef" id="fnref11">11</a></sup>, and some tweaks to the libraries<sup><a href="#fn12" class="footnoteRef" id="fnref12">12</a></sup>. In order to build the libraries and copy them to the <code>examples/</code> directory, I wrote a little script<sup><a href="#fn13" class="footnoteRef" id="fnref13">13</a></sup>, which helps automate this. There is also <code>BuildTest.hs</code> in the <code>examples/</code> dir which gentle reader should try first.</p>
<!-- Part 5: First GHCJS example -->

<p>After much twiddling and fudging with the example file and the provided FFI, some help from Victor Nazarov, with some trial and error, I managed to get some fundamental things working that are necessary to be able to write effectively in the JavaScript environment<sup><a href="#fn14" class="footnoteRef" id="fnref14">14</a></sup>. Timers work (and AJAX requests will), but <a href="https://hpaste.org/50477#line128">this example</a> is merely a clickable blank page which alerts “‘Ello, World!”. Uninteresting functionally, but a good test of the fundamentals (see the pasted Haskell source).</p>
<!-- Part 6: Where next -->

<p>Next up, I will write a simple pong game<sup><a href="#fn15" class="footnoteRef" id="fnref15">15</a></sup> to test integration with the canvas element and speed of the runtime and establish some sort of base library and project template from which other Haskellers can more easily experiment. Perhaps we could even have in the future a browser-based IDE and compiler which can of course run the compiled code in the user’s browser. That would be nice.</p>
<div class="footnotes">
<hr></hr>
<ol>
<li id="fn1"><p>Its support for closures is commonly noted as being one of JavaScript’s redeeming features.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Early binding allows for static verification of the existence of method-signature pairs (e.g. v-tables). Late binding does not give the compiler (or an IDE) enough information for existence verification, it has to be looked up at run-time.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>There are several hinting libraries, which developers insist are indispensable tools when developing JavaScript seriously, such as <a href="https://www.javascriptlint.com/">JavaScript lint</a>, <a href="http://www.jslint.com/">JSLint</a>, and <a href="http://aurochs.fr/jsure.html">JSure</a>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>“Any non-trivial analysis is very difficult due to Javascript’s dynamic nature.” — Berke Durak, Ph.D., author of jsure.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Google Inc. thought it necessary to develop <a href="https://code.google.com/closure/compiler/">a compiler which does type-checking and limited inference</a>, e.g.</p>
<pre><code>/**
 * Queries a Baz for items.
 * @param {number} groupNum Subgroup id to query.
 * @param {string|number|null} term An itemName,
 *     or itemId, or null to search everything.
 */
goog.Baz.prototype.query = function(groupNum, term) {
  ...
};</code></pre>
<p>This will ensure that invocations to <code>Bad.query()</code> will be well-typed. See the <a href="https://code.google.com/closure/compiler/docs/js-for-compiler.html">Google closure docs</a> for more examples. Developers I’ve spoken to at Google say this makes JS bearable with sufficient self-discipline, but without it, maintaining a large codebase in JS is unrealistic.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>A <a href="https://www.google.com/search?aq=f&amp;sourceid=chrome&amp;ie=UTF-8&amp;q=javascript+module+system">quick Google search</a> demonstrates easily enough that there is a need for a module system.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>It is established that JavaScript is now a target platform due to its browser ubiquity. If we want to write tools, applications, games, etc. that will reach a wide audience with little effort on the user’s part, targetting the browser and therefore JavaScript is an excellent option.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>There are already many projects underway for doing this, such as <a href="https://pyjs.org/">Pyjamas</a>, <a href="http://hotruby.yukoba.jp/">HotRuby</a>, <a href="http://ejohn.org/blog/running-java-in-javascript/">Orto</a>, <a href="http://www.zkoss.org/">ZK</a>, and <a href="https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS">many which merely provide a layer ontop of JavaScript</a> to make using it marginally less painful. Some Haskell ones include <a href="http://utrechthaskellcompiler.wordpress.com/2010/10/18/haskell-to-javascript-backend/">UHC</a>, <a href="http://www.haskell.org/haskellwiki/Yhc/Javascript">YHC</a>, <a href="http://code.google.com/p/jshaskell/">jshaskell</a> and <a href="https://github.com/valderman/lambdascript">lambdascript</a>.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Some ways that I see are:</p>
<ul>
<li>Write JavaScript with a functional/OO/“better” standard library, a la <a href="https://github.com/runarorama/LambdaScript">LambdaScript</a> or <a href="https://www.commonjs.org/">CommonJS</a>.</li>
<li>Write JavaScript with additional tools to provide static semantics (a la Google Closure).</li>
<li>Write JavaScript in an EDSL in another more powerful language, e.g. <a href="https://common-lisp.net/project/parenscript/">ParenScript</a> and <a href="http://hackage.haskell.org/package/HJScript">HJScript</a>.</li>
<li>Create a new language that mostly preserves JavaScript semantics but adds some additional layer, e.g. <a href="https://jashkenas.github.com/coffee-script/">CoffeeScript</a>.</li>
<li>Interpret an existing language in JavaScript.</li>
<li>Compile an existing language to JavaScript.</li>
</ul>
<p>I prefer the last option.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>To put it in perspective, here are the extensions available in GHC as of 6.12.3: OverlappingInstances NoOverlappingInstances, IncoherentInstances, NoIncoherentInstances UndecidableInstances, NoUndecidableInstances, Arrows, NoArrows DisambiguateRecordFields, NoDisambiguateRecordFields ForeignFunctionInterface, NoForeignFunctionInterface, Generics NoGenerics, ImplicitParams, NoImplicitParams, NoImplicitPrelude ImplicitPrelude, NoMonomorphismRestriction, MonomorphismRrestriction NoNPlusKPatterns, NPlusKPatterns, NoMonoPatBinds, MonoPatBinds RelaxedPolyRec, NoRelaxedPolyRec, ExtendedDefaultRules NoExtendedDefaultRules, OverloadedStrings, NoOverloadedStrings, GADTs NoGADTs, TypeFamilies, NoTypeFamilies, ScopedTypeVariables NoScopedTypeVariables, MonoLocalBinds, NoMonoLocalBinds, TemplateHaskell NoTemplateHaskell, QuasiQuotes, NoQuasiQuotes, BangPatterns NoBangPatterns, CPP, NoCPP, PatternGuards, NoPatternGuards, ViewPatterns NoViewPatterns, UnicodeSyntax, NoUnicodeSyntax, MagicHash, NoMagicHash NewQualifiedOperators, NoNewQualifiedOperators, ExplicitForALl NoExplicitForAll, PolymorphicComponents, NoPolymorphicComponents Rank2Types, NoRank2Types, RankNTypes, NoRankNTypes, ImpredicativeTypes NoImpredicativeTypes, ExistentialQuantification NoExistentialQuantification, KindSignatures, NoKindSignatures EmptyDataDecls, NoEmptyDataDecls, ParallelListComp, NoParallelListComp TransformListComp, NoTransformListComp, UnliftedFFITypes NoUnliftedFFITypes, LiberalTypeSynonyms, NoLiberalTypeSynonyms TypeOperators, NoTypeOperators, DoRec, NoDoRec, RecursiveDo, NoRecursiveDo PArr, NoPArr, RecordWildCards, NoRecordWildCards, NamedFieldPuns NoNamedFieldPuns, DisambiguateRecordFields, NoDisambiguateRecordFields UnboxedTuples, NoUnboxedTuples, StandaloneDeriving, NoStandaloneDeriving DeriveDataTypeable, NoDeriveDataTypeable, GeneralizedNewtypeDeriving NoGeneralizedNewtypeDeriving, TypeSynonymInstances NoTypeSynonymInstances, FlexibleContexts, NoFlexibleContexts FlexibleInstances, NoFlexibleInstances, ConstrainedClassMethods NoConstrainedClassMethods, MultiParamTypeClasses NoMultiParamTypeClasses, FunctionalDependencies NoFunctionalDependencies, PackageImports, and NoPackageImports.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>On Ubuntu, I had to explicitly add -pthread to the build configuration of libraries/unix, otherwise it didn’t figure it out automatically.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>There were maybe 5 <code>foo#</code> shaped functions that were out of scope throughout the base libraries, particularly in GHC. I simply replaced these with <code>undefined</code>, or because that’s not available, <code>let    a = a in a</code>, or whatever bottom value to stop it complaining. I don’t know whether GHC will detect <code>let a = a in a</code>, I think it does. So the runtime will just throw an exception on these values.</p>
<pre><code>   chris@cn-done:~$ cat &gt; loop.hs
   main = putStrLn $ let r = r in r
   chris@cn-done:~$ ghc --make loop.hs -O2
   [1 of 1] Compiling Main             ( loop.hs, loop.o )
   Linking loop ...
   chris@cn-done:~$ ./loop
   loop: &lt;&lt;loop&gt;&gt;</code></pre>
<p>Looks OK.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>I called it <code>ghcjs_buildlibs</code>, and run it from the <code>ghc-6.12.3</code> directory. I think it should work fine for GHC 7, too.</p>
<pre><code> JSDIR=$1

 cd libraries/ghc-prim &amp;&amp;
 echo cding to libraries/ghc-prim &amp;&amp;
 ghcjs -odir $JSDIR/ghc-prim \
       -hidir $JSDIR/ghc-prim \
       -cpp -fglasgow-exts \
       -package-name ghc-prim \
       GHC/Types.hs &amp;&amp;
 ghcjs -odir $JSDIR/ghc-prim \
       -hidir $JSDIR/ghc-prim \
       -cpp -fglasgow-exts \
       -package-name ghc-prim \
       GHC/*  &amp;&amp;
 cd ../.. &amp;&amp;
 echo cding to ../.. &amp;&amp;
 cd libraries/integer-simple &amp;&amp;
 echo cding to libraries/integer-simple &amp;&amp;
 ghcjs -odir $JSDIR/integer-simple \
       -hidir $JSDIR/integer-simple \
       -cpp -fglasgow-exts \
       -package-name integer-simple \
       GHC/Integer.hs &amp;&amp;
 cd ../.. &amp;&amp;
 echo cding to ../.. &amp;&amp;
 cd libraries/base &amp;&amp;
 echo cding to libraries/base &amp;&amp;
 ghcjs -odir $JSDIR/base -hidir $JSDIR/base \
       -hide-package base \
       -package-name base \
       -I./include \
       -i./dist-install/build -XMagicHash \
       -XExistentialQuantification \
       -XRank2Types -XScopedTypeVariables \
       -XUnboxedTuples -XForeignFunctionInterface \
       -XUnliftedFFITypes -XDeriveDataTypeable \
       -XGeneralizedNewtypeDeriving -XFlexibleInstances \
       -XStandaloneDeriving -XPatternGuards \
       -XEmptyDataDecls -XNoImplicitPrelude -XCPP \
       Prelude.hs &amp;&amp;
 echo &quot;Copying lib to main ...&quot; &amp;&amp;
 cp $1/ghc-prim/GHC \
    $1/../main/ -R &amp;&amp;
 cp $1/integer-simple/GHC/ \
    $1/../main/ -R &amp;&amp;
 cp $1/base/* \
    $1/../main/ -R</code></pre>
<a href="#fnref13">↩</a></li>
<li id="fn14"><p>I.e. a way to use closure callbacks for e.g. setInterval/setTimeout and AJAX, a way to serialize data structures like strings and arrays from/to Haskell and JavaScript, and a way to access the DOM and bind events to it.<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>Pong is a good demo. I’ve already started work on this, but hit some walls when trying to separate the build into a more generic and less example-y structure. It’s quite easy to break this system at present.<a href="#fnref15">↩</a></p></li>
</ol>
</div>

<footer>
  © 2011-08-20 Chris Done &lt;chrisdone@gmail.com&gt;
<span style="float:right"><a href="../rss.xml">RSS</a></span>
</footer>

    </div>

  </body>
</html>
