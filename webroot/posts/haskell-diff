<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Haskell structured diffs</title>
  <style>body {
  max-width: 40em;
  margin: .5in auto;
  font-size: 18px;
  font-family: serif;
  margin-top: 5em;
  line-height: 1.5;
}
pre, code {
  font-size: 16px;
}
pre {
  margin-left: 1.5em;
  line-height: 1.2;
}
a {
  color: #1a6e8e
}
.menu a {
  margin-right: 1em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Helvetica;
}

h1 a,h2 a,h3 a,h4 a {
  text-decoration: none;
  color: inherit;
}

.post-1,.post-2{
  margin-bottom: 0.5em;
}

.author {
  display: none;
}

footer {
  margin-top: 1.5em;
  padding-top: 1.5em;
  border-top: 1px solid #ccc;
  margin-bottom: 2em
}

footer span {
  display: none;
}

img {
  max-width: 100%
}
pre.sourceCode span.st {
  color: #366354
}
pre.sourceCode span.kw {
  color: #397460
}
pre.sourceCode span.fu {
  color: #8f4e8b
}
pre.sourceCode span.ot {
  color: #2e659c
}
pre.sourceCode span.dt {
  color: #4F4371
}
pre.sourceCode span.co {
  color: #666
}
  </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>Haskell structured diffs</h1>
<p class="author">By <a href="https://chrisdone.com/">Chris Done</a></p>

<p>Project-request: someone please implement a program that will diff Haskell in a cleverer way than lines.</p>
<p>In an effort to reign in my incessant work on Haskell tooling<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>, I’m outlining a tool that I’d personally like and welcome people to implement it. Otherwise it serves as a motivating problem description for the next time I come around to it myself with free time.</p>
<p>Before anyone emails me saying “lines/words are simple, other things are hard, that’s why it’s not been done yet. People undervalue the simple solution …” with a long lecture, spare me!</p>
<h2 id="the-concrete-diff">The concrete diff</h2>
<p>The concrete diff is the line-based, and sometimes character-based, diff that we all know and love. There’s no reason to throw this away. You will need to keep this as an optional backend for when you are unable to parse a Haskell file.</p>
<p>Pros: simple to implement. You produce the necessary lines to delete and insert to create the change from A to B.</p>
<p>Cons: doesn’t know about syntactic redundancy where some changes don’t mean anything, and where the actual important change occurs. For example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Write your name!&quot;</span>
          name <span class="ot">&lt;-</span> getLine
          print name</code></pre>
<p>Now you change this to:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span> args <span class="ot">&lt;-</span> getArgs
          <span class="kw">case</span> args <span class="kw">of</span>
            [] <span class="ot">-&gt;</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Write your name!&quot;</span>
                     name <span class="ot">&lt;-</span> getLine
                     print name
            _ <span class="ot">-&gt;</span> runWithArgs args</code></pre>
<p>The diff will look like this:</p>
<pre class="sourceCode diff"><code class="sourceCode diff"><span class="dt">@@ -5,3 +5,6 @@ module Main where</span>
<span class="st">-main = do putStrLn &quot;Write your name!&quot;</span>
<span class="st">-          name &lt;- getLine</span>
<span class="st">-          print name</span>
<span class="ot">+main = do args &lt;- getArgs</span>
<span class="ot">+          case args of</span>
<span class="ot">+            [] -&gt; do putStrLn &quot;Write your name!&quot;</span>
<span class="ot">+                     name &lt;- getLine</span>
<span class="ot">+                     print name</span>
<span class="ot">+            _ -&gt; runWithArgs args</span></code></pre>
<p>But it’s clear to observe that this is not the change we made in spirit, it’s just one line-based way to achieve it. In actual fact, our <code>do putStrLn …</code> was moved into a <code>case</code>, un-changed. At this size, it’s not a big deal. When the code is more interesting, it’s important to know what was really changed, and what remains the same.</p>
<h2 id="the-abstract-syntax-diff">The abstract syntax diff</h2>
<p>Enter the syntactic diff. We show the difference between two syntactic trees. How this is to be achieved in a readable way is the rub, but here are some ideas.</p>
<p>Take our example above, one approach can be to label nodes.</p>
<p>Before:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">¹{main <span class="fu">=</span> ²{<span class="kw">do</span> putStrLn <span class="st">&quot;Write your name!&quot;</span>
              name <span class="ot">&lt;-</span> getLine
              print name}}</code></pre>
<p>After:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">¹{main <span class="fu">=</span> <span class="kw">do</span> args <span class="ot">&lt;-</span> getArgs
            <span class="kw">case</span> args <span class="kw">of</span>
              [] <span class="ot">-&gt;</span> ²{<span class="kw">do</span> putStrLn <span class="st">&quot;Write your name!&quot;</span>
                         name <span class="ot">&lt;-</span> getLine
                         print name}
              _ <span class="ot">-&gt;</span> runWithArgs args}</code></pre>
<p>Now, at least at a superficial glance, you don’t even need this explained to you. You can see exactly what has happened: The code before has changed to the code after, but we can see that node<sub>2</sub> has just moved to inside the case.</p>
<p>Where the trickiness arises is taking this to its logical conclusion and applying it generally. What’s displayed if you also change the string in the <code>putStrLn</code>? Good question. Here’s an idea:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">¹{main <span class="fu">=</span> ²{<span class="kw">do</span> putStrLn <span class="fu">-</span>{<span class="st">&quot;Write your name!&quot;</span>}
              name <span class="ot">&lt;-</span> getLine
              print name}}</code></pre>
<p>Because the node <code>&quot;Write your name&quot;</code> has now been lost, we don’t need to reference it any longer. So one way to show that it has been removed could be to put <code>-{…}</code>. And then to show what replaced it, put in <code>+{…}</code>, a la classic diffs:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">¹{main <span class="fu">=</span> <span class="fu">+</span>{<span class="kw">do</span> args <span class="ot">&lt;-</span> getArgs
              <span class="kw">case</span> args <span class="kw">of</span>
                [] <span class="ot">-&gt;</span> ²{<span class="kw">do</span> putStrLn <span class="fu">+</span>{<span class="st">&quot;Hello!&quot;</span>}
                           name <span class="ot">&lt;-</span> getLine
                           print name}
                _ <span class="ot">-&gt;</span> runWithArgs args}}</code></pre>
<p>In reality this rule would insert more <code>-{…}</code> and <code>+{…}</code> than I’ve written here, but I’m writing these examples manually so take them with a grain of salt. Let’s take it further and say that the string has actually been moved. Then we should indeed give it a number to reference it later:</p>
<p>Before:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">¹{main <span class="fu">=</span> ²{<span class="kw">do</span> putStrLn ³{<span class="st">&quot;Write your name!&quot;</span>}
              name <span class="ot">&lt;-</span> getLine
              print name}}</code></pre>
<p>After:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">¹{main <span class="fu">=</span> <span class="fu">+</span>{<span class="kw">do</span> args <span class="ot">&lt;-</span> getArgs
              <span class="kw">case</span> args <span class="kw">of</span>
                [] <span class="ot">-&gt;</span> ²{<span class="kw">do</span> putStrLn <span class="fu">+</span>{greeting}
                           name <span class="ot">&lt;-</span> getLine
                           print name}
                _ <span class="ot">-&gt;</span> runWithArgs args}
    <span class="fu">+</span>{<span class="kw">where</span> greeting <span class="fu">=</span> ³{<span class="st">&quot;Write your name!&quot;</span>}}}</code></pre>
<p>Again, I don’t think anybody is going to find this confusing. The node<sub>3</sub> has moved into a <code>where</code> clause, which has been named <code>greeting</code> and referenced in place of its original place.</p>
<p>Am I making obvious sense, here? It’s not a particularly novel display, it states what happened syntactically, precisely. With a UI, you could expand/collapse nodes in a nested fashion or “explode” all the pieces into a flat list of numbered or +’d or -’d nodes, or just narrow down to one specific interesting expression, like</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">²{<span class="kw">do</span> putStrLn <span class="fu">+</span>{greeting}
     name <span class="ot">&lt;-</span> getLine
     print name}</code></pre>
<p>If you’re sufficiently nerd-sniped to find this interesting and do-able, then I invite you to go ahead and give it a go. I’d love to see a prototype. I don’t plan on implementing this in the near or distant future, so we won’t be toe stepping.</p>
<h2 id="the-reduced-semantic-diff">The reduced semantic diff</h2>
<p>If you’re still reading by this point, let me try to entice you with ambitious ideas. Take the above approach, everything we just laid out, but let’s put an additional step in there: instead of diffing Haskell’s abstract syntax tree, diff the Core.</p>
<p>If you compile the below with GHC,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Just</span> () <span class="kw">of</span>
         <span class="dt">Just</span> () <span class="ot">-&gt;</span> print <span class="st">&quot;Hey!&quot;</span></code></pre>
<p>The external core is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">%</span><span class="kw">module</span> main<span class="fu">:</span><span class="dt">Main</span>
  main<span class="fu">:</span><span class="ot">main5 ::</span> (<span class="dt">ZMZN</span> <span class="dt">Char</span>) <span class="fu">=</span> unpackCStringzh (<span class="st">&quot;Hey!&quot;</span><span class="ot">::</span><span class="dt">Addrzh</span>);
  main<span class="fu">:</span><span class="ot">main4 ::</span> (<span class="dt">ZMZN</span> <span class="dt">Char</span>) <span class="fu">=</span> <span class="dt">ZC</span> <span class="fu">@</span> <span class="dt">Char</span> base<span class="fu">:</span>zdfShowChar1 (<span class="dt">ZMZN</span> <span class="fu">@</span> <span class="dt">Char</span>);
  main<span class="fu">:</span><span class="ot">main3 ::</span> (<span class="dt">ZMZN</span> <span class="dt">Char</span>) <span class="fu">=</span> base<span class="fu">:</span>showLitString main<span class="fu">:</span>main5 main<span class="fu">:</span>main4;
  main<span class="fu">:</span><span class="ot">main2 ::</span> (<span class="dt">ZMZN</span> <span class="dt">Char</span>) <span class="fu">=</span> <span class="dt">ZC</span> <span class="fu">@</span> <span class="dt">Char</span> base<span class="fu">:</span>zdfShowChar1 main<span class="fu">:</span>main3;
  main<span class="fu">:</span><span class="ot">main1 ::</span> (<span class="dt">Statezh</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span> (<span class="dt">Z2H</span> ((<span class="dt">Statezh</span> <span class="dt">RealWorld</span>)) <span class="dt">Z0T</span>) <span class="fu">=</span>
    \ (<span class="ot">etaB1::</span>(<span class="dt">Statezh</span> <span class="dt">RealWorld</span>)) <span class="ot">-&gt;</span>
      base<span class="fu">:</span>hPutStr2 base<span class="fu">:</span>stdout main<span class="fu">:</span>main2 <span class="dt">True</span> etaB1;
  main<span class="fu">:</span><span class="ot">main ::</span> (<span class="dt">IO</span> <span class="dt">Z0T</span>) <span class="fu">=</span> <span class="fu">%</span>cast (main<span class="fu">:</span>main1) (<span class="fu">%</span>sym ((<span class="dt">NTCoZCIO</span> <span class="dt">Z0T</span>)));
  main<span class="fu">:</span><span class="ot">main6 ::</span> (<span class="dt">Statezh</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span> (<span class="dt">Z2H</span> ((<span class="dt">Statezh</span> <span class="dt">RealWorld</span>)) <span class="dt">Z0T</span>) <span class="fu">=</span>
    \ (<span class="ot">etaXb::</span>(<span class="dt">Statezh</span> <span class="dt">RealWorld</span>)) <span class="ot">-&gt;</span>
      base<span class="fu">:</span>runMainIO1 <span class="fu">@</span> <span class="dt">Z0T</span> (<span class="fu">%</span>cast (main<span class="fu">:</span>main1) (<span class="fu">%</span>sym ((<span class="dt">NTCoZCIO</span> <span class="dt">Z0T</span>))))
                       etaXb;
  main<span class="fu">:</span><span class="dt">ZCmain</span><span class="ot"> ::</span> (<span class="dt">IO</span> <span class="dt">Z0T</span>) <span class="fu">=</span> <span class="fu">%</span>cast (main<span class="fu">:</span>main6) (<span class="fu">%</span>sym ((<span class="dt">NTCoZCIO</span> <span class="dt">Z0T</span>)));</code></pre>
<p>You can see that the pointless <code>case</code> has been removed. This is the bread and butter of Core simplification. But if I remove the case myself, the Core is exactly the same. This is redundant semantic content, which is why GHC removed it.</p>
<p>If someone made a change like this in a real codebase which removed some redundant <em>semantic</em> content, not just syntactical redundancy, your diff could show it like that. In other words, nothing important semantically actually happened here.</p>
<p>In fact, if I refactored a bunch of code, re-organized a bit, does my next colleague really want to read through all the syntax tree just to see the crux of what changed? Sometimes, but not always. Sometimes, they just want to see the precise thing that will change at runtime.</p>
<p>It might actually be insane, with big blow ups in code difference for minute high-level changes, or it might be great for teams caring about performance. Difficult to know until you try it. You can also do a source-mapping back to the original Haskell source, for a more interesting display.</p>
<p>If you want to implement this, I would love to see any results.</p>
<h2 id="the-typed-diff">The typed diff</h2>
<p>Okay, you’re still reading so you’re pretty easily nerd sniped. Let’s continue with the ideas. Another type of difference between two sources is the types of expressions in there. Consider:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
       <span class="kw">in</span> print (x <span class="fu">&lt;&gt;</span> x)</code></pre>
<p>Now you change the code to:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> myFancyMonoid
       <span class="kw">in</span> print (x <span class="fu">&lt;&gt;</span> x)</code></pre>
<p>Our structural diff laid out earlier will show this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="fu">-</span>{[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]}
       <span class="kw">in</span> print (x <span class="fu">&lt;&gt;</span> x)</code></pre>
<p>After:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="fu">+</span>{myFancyMonoid}
       <span class="kw">in</span> print (x <span class="fu">&lt;&gt;</span> x)</code></pre>
<p>But actually, more things have changed here. As a result of the different monoid instance, the <code>print (x &lt;&gt; x)</code> will do something different. Maybe it’s a <code>*</code> rather than <code>+</code>, maybe it’s a number, whatever. Maybe that expression is used in a more interesting way than merely printing it. What’s the real diff?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">let</span> {<span class="ot">x::</span>[<span class="dt">Integer</span>]} <span class="fu">=</span> <span class="fu">-</span>{[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]}
       <span class="kw">in</span> print {{(x <span class="fu">&lt;&gt;</span> x)}<span class="ot">::</span>[<span class="dt">Integer</span>]}</code></pre>
<p>After:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">let</span> {<span class="ot">x::</span><span class="dt">MyFancyMonoid</span>} <span class="fu">=</span> <span class="fu">+</span>{myFancyMonoid}
       <span class="kw">in</span> print {(x <span class="fu">&lt;&gt;</span> x)}<span class="ot">::</span><span class="dt">MyFancyMonoid</span>}</code></pre>
<p>Or something like that. I’m being hand-wavey in the display, here. The real difference is that we’ve changed the type of <code>x</code>. It’s an important change, which has semantic meaning. My ideas are more vague here. I haven’t thought through many scenarios of how to represent this. But one thing is clear: a diff of types can actually be useful and interesting.</p>
<h2 id="the-editing-diff">The editing diff</h2>
<p>The diffs above are all examples of “cold” diffs. Calculating the difference between two files as-is. If you’re in a structured editor like <a href="https://peaker.github.io/lamdu/">Lamdu</a>, then you don’t have to do cold diffs and figure out and guess at what happened. You know exactly what happened. This node was raised here, this variable was renamed there, etc. But if you want to work on that, you pretty much have to work on Lamdu.</p>
<h2 id="summary">Summary</h2>
<p>In summary I’ve intentionally listed increasingly more wacky diff ideas, from the familiar to the fairly novel. My general approach to tooling is progressive: start with the simplest working implementation then step up. Structured-haskell-mode is an example of this. It’s no Lamdu, and it’s no vanilla text-based mode. It’s a stepping stone inbetween. The impedance to try SHM is lower.</p>
<p>In the same way, maybe we can start with the abstract syntax diff, let people become acclimatized to it, let it stabilize, get it integrated into things like Git, and then work our way up from there.</p>
<p>If nobody bothers trying out these ideas, I’ll probably end up doing them myself eventually, but I thought I’d put the suggestion out there first.</p>
<div class="footnotes">
<hr></hr>
<ol>
<li id="fn1"><p>In favour of writing programs that concern themselves with things other than Haskell for once!<a href="#fnref1">↩</a></p></li>
</ol>
</div>

<footer>
  © 2014-04-01 Chris Done &lt;chrisdone@gmail.com&gt;
<span style="float:right"><a href="../rss.xml">RSS</a></span>
</footer>

    </div>

  </body>
</html>
