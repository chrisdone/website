<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Idle thoughts: More open, more free software</title>
    <style>body {
      max-width: 40em;
      margin: .5in auto;
      font-size: 18px;
      font-family: serif;
      margin-top: 5em;
      line-height: 1.5;
      }
      pre, code {
      font-size: 16px;
      }
      pre {
      margin-left: 1.5em;
      line-height: 1.2;
      }
      a {
      color: #1a6e8e
      }
      .menu a {
      margin-right: 1em;
      }
      h1,h2,h3,h4,h5,h6 {
      font-family: Helvetica;
      }

      h1 a,h2 a,h3 a,h4 a {
      text-decoration: none;
      color: inherit;
      }

      .post-1,.post-2{
      margin-bottom: 0.5em;
      }

      .author {
      display: none;
      }

      footer {
      margin-top: 1.5em;
      padding-top: 1.5em;
      border-top: 1px solid #ccc;
      margin-bottom: 2em
      }

      footer span {
      display: none;
      }

      img {
      max-width: 100%
      }
      pre.sourceCode span.st {
      color: #366354
      }
      pre.sourceCode span.kw {
      color: #397460
      }
      pre.sourceCode span.fu {
      color: #8f4e8b
      }
      pre.sourceCode span.ot {
      color: #2e659c
      }
      pre.sourceCode span.dt {
      color: #4F4371
      }
      pre.sourceCode span.co {
      color: #666
      }
    </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>
Idle thoughts: More open, more free software
</h1>
<p>I’m a bit busy, these are just some idle thoughts.</p>
<p>I just upgraded my Android OS to some other kind of dessert name and a bunch of stuff changed in a way I had no desire for.</p>
<p>It made me think about the virtues of open source software. I can just go and change it! Free software means benefiting from the work of others without being shackled by them at the same time.</p>
<p>And then about the problems of open source software, which is that only developers-skilled developers-with specific knowledge, are able to approach the codebase of an app they use, update it, and then use that new software in a continuous and smooth way. Everyone else’s hands are effectively tied behind their backs.</p>
<p>So that got me thinking about how software could be more “open” than simply “open source”, if it was inherently more configurable. And also about better migration information from one piece of software to the next.</p>
<p>So I imagined a world in which when I get an update for a piece of software I could see a smart diff, as a regular human, of what the new UI and behaviour looks like, how it changed. This button moved there, changed color. Pressing this button used to exhibit X behaviour, now that behaviour is more complicated, or more limited, to trigger this action, and so on.</p>
<p>I believe that a properly declarative UI library with explicit state modeling, such as <a href="http://elm-lang.org/guide/model-the-problem">in Elm</a> or whatnot, could actually handle a thing like that, but that it would have to be designed from the bottom up like that. And every component would need to have some “mock” meta-data about it, so that the migration tool could say “here’s what the old UI looks like with lorem ipsum data in it and here’s what that same data, migrated, looks like in the new UI” and you could interact with this fake UI on fake data, with no consequences. Or interact with the user’s data in a read-only “fake” way.</p>
<p>You could say: actually, no, I want to configure that this button will stay where it is, that the theme will stay my current dark theme, etc.</p>
<p>You could visualize state changes in the UI such as with the time traveling thing in Elm or React and make new decision trees, or perhaps pick between built-in behaviours.</p>
<p>But one key idea could be that when you update software in a new way, unless you’re removing the ability to do a feature completely (e.g. the server won’t even respond to that RPC call), then you should indicate that, in the intelligent “software diff”: then the user can say, no I still want to use that and now they have a “patched” or “forked” version of the software locally but that the maintainers of the software don’t have to worry about.</p>
<p>Normally configuring software is a thing developers manually hard code into the product. It seems obviously better to make software inherently configurable, from a free software perspective at least (not from a proprietary locked-in perspective).</p>
<p>Of course, you could write code at any time; drop down to that. But if most of the code can be self-describing at least in a high-level “do the thing or that thing” way, this would be far more accessible to general users than code itself which at the moment is magic and certainly beyond my interest to go and patch for the most part.</p>

<footer>
  © 2015-10-26 Chris Done
</footer>

    </div>
  </body>
</html>
