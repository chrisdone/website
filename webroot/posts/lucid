<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Lucid: templating DSL for HTML</title>
  <style>body {
  max-width: 40em;
  margin: .5in auto;
  font-size: 18px;
  font-family: serif;
  margin-top: 5em;
  line-height: 1.5;
}
pre, code {
  font-size: 16px;
}
pre {
  margin-left: 1.5em;
  line-height: 1.2;
}
a {
  color: #1a6e8e
}
.menu a {
  margin-right: 1em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Helvetica;
}

h1 a,h2 a,h3 a,h4 a {
  text-decoration: none;
  color: inherit;
}

.post-1,.post-2{
  margin-bottom: 0.5em;
}

.author {
  display: none;
}

footer {
  margin-top: 1.5em;
  padding-top: 1.5em;
  border-top: 1px solid #ccc;
  margin-bottom: 2em
}

footer span {
  display: none;
}

img {
  max-width: 100%
}
pre.sourceCode span.st {
  color: #366354
}
pre.sourceCode span.kw {
  color: #397460
}
pre.sourceCode span.fu {
  color: #8f4e8b
}
pre.sourceCode span.ot {
  color: #2e659c
}
pre.sourceCode span.dt {
  color: #4F4371
}
pre.sourceCode span.co {
  color: #666
}
  </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>Lucid: templating DSL for HTML</h1>
<p class="author">By <a href="https://chrisdone.com/">Chris Done</a></p>

<p>I’m not big on custom templating languages, for reasons I’ll write about another time. I prefer EDSLs. I preferred the <a href="https://hackage.haskell.org/package/xhtml">xhtml</a> package back when that was what everybody used. It looked like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">header <span class="fu">&lt;&lt;</span> thetitle <span class="fu">&lt;&lt;</span> <span class="st">&quot;Page title&quot;</span>

thediv noHtml <span class="fu">!</span> [theclass <span class="st">&quot;logo&quot;</span>] <span class="fu">&lt;&lt;</span> <span class="st">&quot;…&quot;</span>
thediv noHtml <span class="fu">!</span> [identifier <span class="st">&quot;login&quot;</span>]</code></pre>
<p>Pretty line-noisy to read, write and hard to edit in a reasonable manner.</p>
<p>Later, <a href="https://hackage.haskell.org/package/blaze-html">blaze-html</a> became the new goto HTML writing library. It improved upon the XHTML package by being faster and having a convenient monad instance. It looks like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">page1 <span class="fu">=</span> html <span class="fu">$</span> <span class="kw">do</span>
    head <span class="fu">$</span> <span class="kw">do</span>
        title <span class="st">&quot;Introduction page.&quot;</span>
        link <span class="fu">!</span> rel <span class="st">&quot;stylesheet&quot;</span> <span class="fu">!</span> type_ <span class="st">&quot;text/css&quot;</span> <span class="fu">!</span> href <span class="st">&quot;screen.css&quot;</span>
    body <span class="fu">$</span> <span class="kw">do</span>
        div <span class="fu">!</span> id <span class="st">&quot;header&quot;</span> <span class="fu">$</span> <span class="st">&quot;Syntax&quot;</span>
        p <span class="st">&quot;This is an example of BlazeMarkup syntax.&quot;</span>
        ul <span class="fu">$</span> mapM_ (li <span class="fu">.</span> toMarkup <span class="fu">.</span> show) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre>
<p>Much easier to read, write and edit thanks to the monad instance.</p>
<p>However, after several years of using that, I’ve come to write my own. I’ll cover the infelicities about Blaze and then discuss my alternative approach.</p>
<p>Reading back through what I’ve written below, it could be read as a bit attacky, and some of the issues are less philosophical and more incidental. I think of it more that the work on writing HTML in a DSL is incomplete and to some degree people somewhat gave up on doing it more conveniently at some point. So I’m re-igniting that.</p>
<p>The combination of having a need to write a few HTML reports and recent discussions about Blaze made me realise it was time for me to come at this problem a-fresh with my own tastes in mind. I also haven’t used my own approach much, other than porting some trivial apps to it.</p>
<h1 id="blaze">Blaze</h1>
<h2 id="names-that-conflict-with-base">Names that conflict with base</h2>
<p>The first problem is that Blaze exports many names which conflict with base. Examples:</p>
<p><code>div</code>, <code>id</code>, <code>head</code>, <code>map</code></p>
<p>The obvious problem with this is that you either have to qualify any use of those names, which means you have to qualify Blaze, and end up with something inconsistent like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">H.div <span class="fu">!</span> A.id <span class="st">&quot;logo&quot;</span> <span class="fu">$</span> <span class="st">&quot;…&quot;</span></code></pre>
<p>Where <code>H</code> and <code>A</code> come from importing the element and attribute modules like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="kw">qualified</span> Text.Blaze.Html5            <span class="kw">as</span> H
<span class="kw">import</span> <span class="kw">qualified</span> Text.Blaze.Html5.Attributes <span class="kw">as</span> A</code></pre>
<p>Or you don’t import <code>Prelude</code> and only import Blaze, but then you can’t do a simple <code>map</code> without qualification.</p>
<p>You might’ve noticed in the old <code>xhtml</code> package that <code>thediv</code> and <code>identifier</code> are used instead. The problem with using different names from the actual things they refer to is that they’re hard to learn and remember, both for regular Haskellers and newbies coming to edit your templates.</p>
<h2 id="names-that-are-keywords">Names that are keywords</h2>
<p>This is a common problem in DSLs, too. In Blaze the problem is: <code>class</code> or <code>type</code> (perhaps others I don’t recall). Blaze solves it with: <code>class_</code> or <code>type_</code></p>
<p>Again, the problem with this is that it is inconsistent with the other naming conventions. It’s another exception to the rule that you have to remember and makes the code look bad.</p>
<h2 id="conflicting-attribute-and-element-names">Conflicting attribute and element names</h2>
<p>There are also names which are used for both attributes and elements. Examples are <code>style</code> and <code>map</code>. That means you can’t write:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">H.head <span class="fu">$</span> style <span class="st">&quot;body { background: red; }&quot;</span>
body <span class="fu">$</span> p <span class="fu">!</span> style <span class="st">&quot;foo&quot;</span> <span class="fu">$</span> …</code></pre>
<p>You end up writing:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">H.head <span class="fu">$</span> H.style <span class="st">&quot;body { background: red; }&quot;</span>
body <span class="fu">$</span> p <span class="fu">!</span> A.style <span class="st">&quot;foo&quot;</span> <span class="fu">$</span> …</code></pre>
<h2 id="inconsistency-is-difficult-and-ugly">Inconsistency is difficult and ugly</h2>
<p>What the above problems amount to is ending up with code like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">body <span class="fu">$</span> H.div <span class="fu">!</span> A.id <span class="st">&quot;logo&quot;</span> <span class="fu">!</span> class_ <span class="st">&quot;left&quot;</span> <span class="fu">!</span> hidden <span class="fu">$</span> <span class="st">&quot;Content&quot;</span></code></pre>
<p>At this point users of Blaze give up with second-guessing every markup term they write and decide it’s more consistent to qualify <em>everything</em>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">H.body <span class="fu">$</span> H.div <span class="fu">!</span> A.id <span class="st">&quot;logo&quot;</span> <span class="fu">!</span> A.class_ <span class="st">&quot;left&quot;</span> <span class="fu">!</span> A.hidden <span class="fu">$</span> <span class="st">&quot;Content&quot;</span></code></pre>
<p>Or, taken from some real code online:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">H.input <span class="fu">H.!</span> A.type_ <span class="st">&quot;checkbox&quot;</span>
        <span class="fu">H.!</span> A.checked <span class="dt">True</span>
        <span class="fu">H.!</span> A.readonly <span class="st">&quot;true&quot;</span></code></pre>
<p>This ends up being too much. Inconvenient to type, ugly to read, and one more step removed from the HTML we’re supposed to be generating.</p>
<h2 id="the-monad-instance-isnt">The Monad instance isn’t</h2>
<p>The monad instance was originally conceived as a handy way to write HTML nicely without having to use <code>&lt;&gt;</code> or lists of lists and other less wieldy syntax.</p>
<p>In the end the monad ended up being defined like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">MarkupM</span> <span class="kw">where</span>
  return _ <span class="fu">=</span> <span class="dt">Empty</span>
  <span class="ot">{-# INLINE return #-}</span>
  (<span class="fu">&gt;&gt;</span>) <span class="fu">=</span> <span class="dt">Append</span>
  <span class="ot">{-# INLINE (&gt;&gt;) #-}</span>
  h1 <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> h1 <span class="fu">&gt;&gt;</span> f
      (error <span class="st">&quot;Text.Blaze.Internal.MarkupM: invalid use of monadic bind&quot;</span>)
  <span class="ot">{-# INLINE (&gt;&gt;=) #-}</span></code></pre>
<p>And has been for some years. Let’s take a trivial example of why this is not good. You render some HTML and while doing so build a result to be used later:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> xs <span class="ot">&lt;-</span> foldM (\c i <span class="ot">-&gt;</span> …)
               mempty
               ys
   mapM_ dd xs</code></pre>
<p>Uh-oh:</p>
<pre><code>*** Exception: Text.Blaze.Internal.MarkupM: invalid use of monadic bind</code></pre>
<h2 id="the-overloaded-strings-instance-is-bad">The overloaded strings instance is bad</h2>
<p>The previous point leads onto this next point, which is that due to this phantomesque monad type, the instance is like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">MarkupM</span> a) <span class="kw">where</span>
    fromString <span class="fu">=</span> <span class="dt">Content</span> <span class="fu">.</span> fromString
    <span class="ot">{-# INLINE fromString #-}</span></code></pre>
<p>How can it make this value? It cannot. If you want to go ahead and extract that `a’, you get:</p>
<pre><code>*** Exception: Text.Blaze.Internal.MarkupM: invalid use of monadic bind</code></pre>
<p>Additionally, this instance is too liberal. You end up getting this warning:</p>
<blockquote>
<p>A do-notation statement discarded a result of type <code>GHC.Prim.Any</code></p>
<p>Suppress this warning by saying <code>_ &lt;- &quot;Example&quot;</code> or by using the flag <code>-fno-warn-unused-do-bind</code></p>
</blockquote>
<p>So you end up having to write in practice (again, taken from a real Blaze codebase by one of the authors):</p>
<pre><code>void &quot;Hello!&quot;</code></pre>
<p>Which pretty much negates the point of using <code>IsString</code> in the first-place. Alternatively, you use <code>-fno-warn-unused-do-bind</code> in your module.</p>
<h2 id="working-with-attributes-is-awkward">Working with attributes is awkward</h2>
<p>The ! syntax seems pretty convenient from superficial inspection:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">link <span class="fu">!</span> rel <span class="st">&quot;stylesheet&quot;</span> <span class="fu">!</span> type_ <span class="st">&quot;text/css&quot;</span> <span class="fu">!</span> href <span class="st">&quot;screen.css&quot;</span></code></pre>
<p>But in practice it means you always have the same combination:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">div <span class="fu">!</span> H.class_ <span class="st">&quot;logo&quot;</span> <span class="fu">$</span> <span class="st">&quot;…&quot;</span></code></pre>
<p>Which I find—personally speaking—a bit distasteful to read, it’s not far from what we saw in the old xhtml package:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">thediv <span class="fu">!</span> [theclass <span class="st">&quot;logo&quot;</span>] <span class="fu">&lt;&lt;</span> <span class="st">&quot;…&quot;</span></code></pre>
<p>Did we really save that much in the attribute department? Operators are evil.</p>
<p>But mostly presents an editing challenge. Operators like this make it tricky to navigate, format in a regular way and do code transformations on. All Haskell code has operators, so this is a general problem. But if your DSL doesn’t actually need these operators, I consider this a smell.</p>
<h2 id="attributes-dont-compose">Attributes don’t compose</h2>
<p>You should be able to compose <code>with</code>. For example, let’s say you want to define a re-usable component with bootstrap:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">container inner <span class="fu">=</span> div <span class="fu">!</span> class_ <span class="st">&quot;container&quot;</span> <span class="fu">$</span> inner</code></pre>
<p>Now you can use it to make a container. But consider now that you also want to add additional attributes to it later. You can do that with another call to with:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">container <span class="fu">!</span> class_ <span class="st">&quot;main&quot;</span> <span class="fu">$</span> <span class="st">&quot;zot&quot;</span></code></pre>
<p>In Blaze this produces:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; main
<span class="st">&quot;&lt;div class=\&quot;container\&quot; class=\&quot;main\&quot;&gt;My content!&lt;/div&gt;&quot;</span></code></pre>
<p>Browsers ignore the latter main, so the composition didn’t work.</p>
<h2 id="ceremony-is-tiring">Ceremony is tiring</h2>
<p>Here’s the example from Blaze’s package, that’s introduced to users.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Prelude <span class="kw">hiding</span> (head, id, div)
<span class="kw">import</span> Text.Blaze.Html4.Strict <span class="kw">hiding</span> (map)
<span class="kw">import</span> Text.Blaze.Html4.Strict.Attributes <span class="kw">hiding</span> (title)
<span class="kw">import</span> Text.Blaze.Renderer.Utf8 (renderMarkup)

<span class="ot">page1 ::</span> <span class="dt">Markup</span>
page1 <span class="fu">=</span> html <span class="fu">$</span> <span class="kw">do</span>
    head <span class="fu">$</span> <span class="kw">do</span>
        title <span class="st">&quot;Introduction page.&quot;</span>
        link <span class="fu">!</span> rel <span class="st">&quot;stylesheet&quot;</span> <span class="fu">!</span> type_ <span class="st">&quot;text/css&quot;</span> <span class="fu">!</span> href <span class="st">&quot;screen.css&quot;</span>
    body <span class="fu">$</span> <span class="kw">do</span>
        div <span class="fu">!</span> id <span class="st">&quot;header&quot;</span> <span class="fu">$</span> <span class="st">&quot;Syntax&quot;</span>
        p <span class="st">&quot;This is an example of BlazeMarkup syntax.&quot;</span>
        ul <span class="fu">$</span> mapM_ (li <span class="fu">.</span> toMarkup <span class="fu">.</span> show) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]

main <span class="fu">=</span> print (renderMarkup page1)</code></pre>
<p>Apart from the import backflips you have to do to resolve names properly, you have at least three imports to make just to render some HTML. Call me lazy, or stupid, but I never remember this deep hierarchy of modules and always have to look it up every single time. And I’ve been using Blaze for as long as the authors have.</p>
<h2 id="transforming">Transforming</h2>
<p>A smaller complaint is that it would sometimes be nice to transform over another monad. Simplest example is storing the read-only model information in a reader monad and then you don’t have to pass around a bunch of things as arguments to all your view functions. I’m a big fan of function arguments for explicit state, but not so much if it’s the same argument every time.</p>
<h2 id="no-show-instance">No Show instance</h2>
<p>It would be nice if you could just write some markup in the REPL without having to import some other modules and wrap it all in a function just to see it.</p>
<h1 id="lucid">Lucid</h1>
<p>My new library, Lucid, attempts to solve most of these problems.</p>
<h2 id="naming-issues">Naming issues</h2>
<p>Firstly, <em>all</em> names which are representations of HTML terms are suffixed with an underscore <code>_</code>:</p>
<pre><code>p_, class_, table_, style_</code></pre>
<p>No ifs or buts. <em>All markup terms.</em></p>
<p>That solves the following problems (from the issues described above):</p>
<ul>
<li>Names that conflict with base: <code>div_</code>, <code>id_</code>, <code>head_</code>, <code>map_</code>, etc.</li>
<li>Names that are keywords: <code>class_</code>, <code>type_</code>, etc.</li>
<li>Conflicting attribute and element names: solved by abstracting those names via a class. You can write <code>style_</code> to mean either the element name or the attribute name.</li>
<li>Inconsistency is difficult and ugly: there’s no inconsistency, all names are the same format.</li>
</ul>
<p>No import problems or qualification. Just write code without worrying about it.</p>
<h2 id="how-it-looks">How it looks</h2>
<p>Plain text is written using the <code>OverloadedStrings</code> and <code>ExtendedDefaultRules</code> extensions, and is automatically escaped:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="st">&quot;123 &lt; 456&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
<span class="dv">123</span> <span class="fu">&amp;</span>lt; <span class="dv">456</span></code></pre>
<p>Elements nest by function application:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; table_ (tr_ (td_ (p_ <span class="st">&quot;Hello, World!&quot;</span>)))
<span class="fu">&lt;</span>table<span class="fu">&gt;&lt;</span>tr<span class="fu">&gt;&lt;</span>td<span class="fu">&gt;&lt;</span>p<span class="fu">&gt;</span><span class="dt">Hello</span>, <span class="dt">World</span><span class="fu">!&lt;/</span>p<span class="fu">&gt;&lt;/</span>td<span class="fu">&gt;&lt;/</span>tr<span class="fu">&gt;&lt;/</span>table<span class="fu">&gt;</span></code></pre>
<p>Elements are juxtaposed via monoidal append:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; p_ <span class="st">&quot;hello&quot;</span> <span class="fu">&lt;&gt;</span> p_ <span class="st">&quot;sup&quot;</span>
<span class="fu">&lt;</span>p<span class="fu">&gt;</span>hello<span class="fu">&lt;/</span>p<span class="fu">&gt;&lt;</span>p<span class="fu">&gt;</span>sup<span class="fu">&lt;/</span>p<span class="fu">&gt;</span></code></pre>
<p>Or monadic sequencing:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; div_ (<span class="kw">do</span> p_ <span class="st">&quot;hello&quot;</span>; p_ <span class="st">&quot;sup&quot;</span>)
<span class="fu">&lt;</span>div<span class="fu">&gt;&lt;</span>p<span class="fu">&gt;</span>hello<span class="fu">&lt;/</span>p<span class="fu">&gt;&lt;</span>p<span class="fu">&gt;</span>sup<span class="fu">&lt;/</span>p<span class="fu">&gt;&lt;/</span>div<span class="fu">&gt;</span></code></pre>
<p>Attributes are set using the with combinator:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; with p_ [class_ <span class="st">&quot;brand&quot;</span>] <span class="st">&quot;Lucid Inc&quot;</span>
<span class="fu">&lt;</span>p <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;brand&quot;</span><span class="fu">&gt;</span><span class="dt">Lucid</span> <span class="dt">Inc</span><span class="fu">&lt;/</span>p<span class="fu">&gt;</span></code></pre>
<p>Conflicting attributes (like <code>style_</code>) work for attributes or elements:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; html_ (head_ (style_ <span class="st">&quot;body{background:red}&quot;</span>) <span class="fu">&lt;&gt;</span>
                 with body_ [style_ <span class="st">&quot;color:white&quot;</span>]
                      <span class="st">&quot;Look ma, no qualification!&quot;</span>)
<span class="fu">&lt;</span>html<span class="fu">&gt;&lt;</span>head<span class="fu">&gt;&lt;</span>style<span class="fu">&gt;</span>body{background<span class="fu">:</span>red}<span class="fu">&lt;/</span>style<span class="fu">&gt;&lt;/</span>head<span class="fu">&gt;</span>
<span class="fu">&lt;</span>body style<span class="fu">=</span><span class="st">&quot;color:white&quot;</span><span class="fu">&gt;</span><span class="dt">Look</span> ma, no qualification<span class="fu">!&lt;/</span>body<span class="fu">&gt;&lt;/</span>html<span class="fu">&gt;</span></code></pre>
<h2 id="the-blaze-example">The Blaze example</h2>
<p>For comparison, here’s the Blaze example again:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">page1 <span class="fu">=</span> html <span class="fu">$</span> <span class="kw">do</span>
    head <span class="fu">$</span> <span class="kw">do</span>
        title <span class="st">&quot;Introduction page.&quot;</span>
        link <span class="fu">!</span> rel <span class="st">&quot;stylesheet&quot;</span> <span class="fu">!</span> type_ <span class="st">&quot;text/css&quot;</span> <span class="fu">!</span> href <span class="st">&quot;screen.css&quot;</span>
    body <span class="fu">$</span> <span class="kw">do</span>
        div <span class="fu">!</span> id <span class="st">&quot;header&quot;</span> <span class="fu">$</span> <span class="st">&quot;Syntax&quot;</span>
        p <span class="st">&quot;This is an example of BlazeMarkup syntax.&quot;</span>
        ul <span class="fu">$</span> mapM_ (li <span class="fu">.</span> toMarkup <span class="fu">.</span> show) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre>
<p>And the same thing in Lucid:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">page2 <span class="fu">=</span> html_ <span class="fu">$</span> <span class="kw">do</span>
    head_ <span class="fu">$</span> <span class="kw">do</span>
      title_ <span class="st">&quot;Introduction page.&quot;</span>
      with link_ [rel_ <span class="st">&quot;stylesheet&quot;</span>,type_ <span class="st">&quot;text/css&quot;</span>,href_ <span class="st">&quot;screen.css&quot;</span>]
    body_ <span class="fu">$</span> <span class="kw">do</span>
        with div_ [id_ <span class="st">&quot;header&quot;</span>] <span class="st">&quot;Syntax&quot;</span>
        p_ <span class="st">&quot;This is an example of Lucid syntax.&quot;</span>
        ul_ <span class="fu">$</span> mapM_ (li_ <span class="fu">.</span> toHtml <span class="fu">.</span> show) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre>
<p>I’m not into operators like <code>($)</code> and swung indentation like that, but I followed the same format.</p>
<p>I’d write it in a more Lispy style and run my hindent tool on it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">page1 <span class="fu">=</span>
  html_ (<span class="kw">do</span> head_ (<span class="kw">do</span> title_ <span class="st">&quot;Introduction page.&quot;</span>
                      with link_
                           [rel_ <span class="st">&quot;stylesheet&quot;</span>
                           ,type_ <span class="st">&quot;text/css&quot;</span>
                           ,href_ <span class="st">&quot;screen.css&quot;</span>])
            body_ (<span class="kw">do</span> with div_ [id_ <span class="st">&quot;header&quot;</span>] <span class="st">&quot;Syntax&quot;</span>
                      p_ <span class="st">&quot;This is an example of Lucid syntax.&quot;</span>
                      ul_ (mapM_ (li_ <span class="fu">.</span> toHtml <span class="fu">.</span> show)
                                 [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])))</code></pre>
<p>But that’s another discussion.</p>
<h2 id="its-a-real-monad">It’s a real monad</h2>
<p>Normal monadic operations work properly:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; (return <span class="st">&quot;OK!&quot;</span> <span class="fu">&gt;&gt;=</span> p_)
<span class="fu">&lt;</span>p<span class="fu">&gt;</span><span class="dt">OK</span><span class="fu">!&lt;/</span>p<span class="fu">&gt;</span></code></pre>
<p>It’s basically a writer monad.</p>
<p>In fact, it’s also a monad transformer:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; runReader (renderTextT (html_ (body_ (<span class="kw">do</span> name <span class="ot">&lt;-</span> lift ask
                                            p_ (toHtml name)))))
             (<span class="st">&quot;Chris&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)
<span class="st">&quot;&lt;html&gt;&lt;body&gt;&lt;p&gt;Chris&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span></code></pre>
<h2 id="overloaded-strings-instance-is-fine">Overloaded strings instance is fine</h2>
<p>The instance is constrained over the return type being <code>()</code>. So string literals can only be type <code>HtmlT m ()</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">do</span> <span class="st">&quot;x&quot;</span> <span class="fu">&gt;&gt;</span> <span class="st">&quot;y&quot;</span><span class="ot"> ::</span> <span class="dt">Html</span> ()
xy

λ&gt; <span class="kw">do</span> x <span class="ot">&lt;-</span> <span class="st">&quot;x&quot;</span>; toHtml (show x)
x()</code></pre>
<h2 id="attributes">Attributes</h2>
<p>Attributes are simply written as a list. That’s all. Easy to manipulate as a data structure, easy to write and edit, and automatically indent in a predictable way:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; with p_ [id_ <span class="st">&quot;person-name&quot;</span>,class_ <span class="st">&quot;attribute&quot;</span>] <span class="st">&quot;Mary&quot;</span>
<span class="fu">&lt;</span>p id<span class="fu">=</span><span class="st">&quot;person-name&quot;</span> <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;attribute&quot;</span><span class="fu">&gt;</span><span class="dt">Mary</span><span class="fu">&lt;/</span>p<span class="fu">&gt;</span></code></pre>
<p>No custom operators are required. Just the <code>with</code> combinator. If you want to indent it, just indent it like normal function application:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">with p_
     [id_ <span class="st">&quot;person-name&quot;</span>,class_ <span class="st">&quot;attribute&quot;</span>]
     <span class="st">&quot;Mary&quot;</span></code></pre>
<p>And you’re done.</p>
<h2 id="composing-attributes">Composing attributes</h2>
<p>You should be able to compose <code>with</code>. For example, let’s say you want to define a re-usable component with bootstrap:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">let</span> container_ <span class="fu">=</span> with div_ [class_ <span class="st">&quot;container &quot;</span>]</code></pre>
<p>Now you can use it to make a container:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; container_ <span class="st">&quot;My content!&quot;</span>
<span class="fu">&lt;</span>div <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;container &quot;</span><span class="fu">&gt;</span><span class="dt">My</span> content<span class="fu">!&lt;/</span>div<span class="fu">&gt;</span></code></pre>
<p>But consider now that you also want to add additional attributes to it later. You can do that with another call to with:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; with container_ [class_ <span class="st">&quot;main&quot;</span>] <span class="st">&quot;My content!&quot;</span>
<span class="fu">&lt;</span>div <span class="kw">class</span><span class="fu">=</span><span class="st">&quot;container main&quot;</span><span class="fu">&gt;</span><span class="dt">My</span> content<span class="fu">!&lt;/</span>div<span class="fu">&gt;</span></code></pre>
<p>Duplicate attributes are composed with normal monoidal append. Note that I added a space in my definition of container anticipating further extension later. Other attributes might not compose with spaces.</p>
<h2 id="unceremonious">Unceremonious</h2>
<p>Another part I made sure was right was lack of import nightmare. You just <code>import Lucid</code> and away you go:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; <span class="kw">import</span> Lucid
λ&gt; p_ <span class="st">&quot;OK!&quot;</span>
<span class="fu">&lt;</span>p<span class="fu">&gt;</span><span class="dt">OK</span><span class="fu">!&lt;/</span>p<span class="fu">&gt;</span>
λ&gt; p_ (span_ (strong_ <span class="st">&quot;Woot!&quot;</span>))
<span class="fu">&lt;</span>p<span class="fu">&gt;&lt;</span>span<span class="fu">&gt;&lt;</span>strong<span class="fu">&gt;</span><span class="dt">Woot</span><span class="fu">!&lt;/</span>strong<span class="fu">&gt;&lt;/</span>span<span class="fu">&gt;&lt;/</span>p<span class="fu">&gt;</span>
λ&gt; renderBS (p_ (span_ (strong_ <span class="st">&quot;Woot!&quot;</span>)))
<span class="st">&quot;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Woot!&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&quot;</span>
λ&gt; renderToFile <span class="st">&quot;/tmp/foo.html&quot;</span> (p_ (span_ (strong_ <span class="st">&quot;Woot!&quot;</span>)))</code></pre>
<p>If I want to do more advanced stuff, it’s all available in <code>Lucid</code>. But by default it’s absolutely trivial to get going and output something.</p>
<h2 id="speed">Speed</h2>
<p>Actually, despite having a trivial implementation, being a real monad and a monad transformer, it’s not far from Blaze. You can compare the <a href="https://imgur.com/a/iyzBl">benchmark reports here</a>. A quick test of writing 38M of HTML to file yielded the same speed (about 1.5s) for both Lucid and Blaze. With such decent performance for very little work I’m already ready to start using it for real work.</p>
<h2 id="summary">Summary</h2>
<p>So the point of this post was really to explain <em>why another HTML DSL</em> and I hope I did that well enough.</p>
<p>The code is <a href="https://github.com/chrisdone/lucid">on Github</a>. I pushed to Hackage but you can consider it beta for now.</p>

<footer>
  © 2014-11-20 Chris Done &lt;chrisdone@gmail.com&gt;
<span style="float:right"><a href="../rss.xml">RSS</a></span>
</footer>

    </div>

  </body>
</html>
