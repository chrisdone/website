<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Emacs users are like Terry Pratchett’s Igors</title>
    <style>
      body {
      max-width: 40em;
      margin: .5in auto;
      font-size: 18px;
      font-family: serif;
      line-height: 1.5;
      }
      pre, code {
      font-size: 16px;
      word-wrap: break-word;
      }
      pre {
      margin-left: 1.5em;
      line-height: 1.2;
      }
      a {
      color: #1a6e8e
      }
      .menu a {
      margin-right: 1em;
      }
      h1,h2,h3,h4,h5,h6 {
      font-family: Helvetica;
      }

      h1 a,h2 a,h3 a,h4 a {
      text-decoration: none;
      color: inherit;
      }

      .post-1,.post-2{
      margin-bottom: 0.5em;
      }

      .author {
      display: none;
      }

      footer {
      margin-top: 1.5em;
      padding-top: 1.5em;
      border-top: 1px solid #ccc;
      margin-bottom: 2em
      }

      footer span {
      display: none;
      }

      img {
      max-width: 100%
      }
      pre.sourceCode span.st {
      color: #366354
      }
      pre.sourceCode span.kw {
      color: #397460
      }
      pre.sourceCode span.fu {
      color: #8f4e8b
      }
      pre.sourceCode span.ot {
      color: #2e659c
      }
      pre.sourceCode span.dt {
      color: #4F4371
      }
      pre.sourceCode span.co {
      color: #666
      }
      @media(max-width:767px){
      body { margin: 1px 4px; }
      h1, h2, .menu { margin: 0; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.125em; }
      h3 { font-size: 1.0125em; }
      .menu a { margin-right: 0.1em; }
      #archive { margin-left: 1em; margin-top: 0; padding: 0}
      #archive .post-1, #archive .post-2 {
      margin-bottom: 0.1em;
      }
      }
    </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>Emacs users are like Terry Pratchett’s Igors</h1>

<p>Within the constraints of the Emacs environment, there are no limits. Emacs is built upon this principle; the Lisp principle. Make some small kernel of features. A substrate. Take care to make this substrate programmable (in any language, Emacs chooses Lisp), and then build the system upon it. Let users worry about future features. Some 359,000 lines of C code comprise its kernel, and 1,637,000 lines of Emacs Lisp take the rest of it.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>Similarly, the nature of The <a href="http://www.winestockwebdesign.com/Essays/Lisp_Curse.html">Lisp Curse</a> is that what can be written to express any given problem is so arbitrary and free, that you are spoiled for choice, and every programmer re-invents solutions to the same problems, uncaring about sharing a common language with the world outside. The core problem is that Lisp makes programmers selfish. Giving programmers so much flexibility is inviting the alienation of other programmers; Lispers think: how can I express this problem best, for me?</p>
<p>That phenomenon is not a problem for Emacs. Work environments are a very personal thing. They exist to serve only one person: you. Me-me-me is a winning attitude when dealing with your environment. Maybe in the real world, out there, where you have to share programs with other people, where other people will see or even use your efforts, you have to care or take consideration about other people. Not in your environment. Not in your Emacs. It is your virtual home for at least nine hours of the day, every day.</p>
<p>My road to Emacs love developed slowly. I first came to it due to Common Lisp. I knew enough Lisp to get by, copy-pasting example snippets, configuring just enough to edit my environment. It felt a little bit barebones compared to the IDEs I’d used before it. Little did I know the world of functionality and configuration waiting beneath my feet.</p>
<p>Eventually I started patching some things here and there, writing my own hooks, little things like that. I used Emacs for a long time, just becoming proficient as a user with the keybindings and window management, before I ever wrote any Elisp. It hadn’t occured to me that writing any Elisp would ever be of interest to me. I would often shaft my .emacs configuration, and everything would break, and I wouldn’t quite know why.</p>
<p>Finally, I wrote my first mode. I think it was a mode for ASP. It wasn’t very good, and I didn’t fully understand everything that was going on. But it gave me some key insights. This thing isn’t just an editor, it’s really an environment all the way down. I can configure <em>everything</em> about this mode. And the mode consists of a bunch of functions and variables. It’s all code.</p>
<p>After that, it was really a sky-rocket of productivity. Eventually I would write Elisp casually in between programming on work projects. I would notice that a way of working was repetitive, or that Emacs behaved in a way I just didn’t quite like, or I simply thought of a nice thing that I could add. I’d happily spend anywhere from 30 seconds to half an hour writing some functionality to extend my editing facilities.</p>
<p>And it was extended for good. That amazed me, and still does. My problems are only problems for as long as I don’t notice them. Once I do, I write some Elisp to solve it, and then it’s never a problem again. In typical editors and IDEs, I simply wouldn’t even think of fixing such things, never mind actually putting my work to one side for a minute, solving them, and then going back to work again.</p>
<p>I’ve now written a lot of Elisp to support my development, especially with respect to Haskell. Many times, for many months at a time, over the years, I’ve been working on an experimental feature, or feature set, mode, what-have-you, and it’s been very spotty. Mostly working, but breaking a lot, interrupting my work, but with me persevering, pushing through, until that work becomes stable and quite robust through sheer usage and battle testing.</p>
<p>When working recently it occured to me that a lot of the functionality I depend on presently in Emacs for work is built upon my own work. I use the session/interactive-mode work for interacting with Cabal and GHCi, I use structured-haskell-mode in conjunction with that, and then atop that I use god-mode, my own Emacs input method. At one time or another in the past they have all been unusable, or flaky as hell. SHM still has a few growing pains, but is basically there.</p>
<p>This really reminds me of Terry Pratchett’s <a href="http://en.wikipedia.org/wiki/Igor_%28Discworld%29">Igor</a> clan. I discovered this amiable race in The Fifth Elephant. Igors are a people inspired from the typical hunchbacked Igor archetype, but in Discworld, they are also self-modifiers. Their bodies consist of mixed and matched and patched and swapped body parts among other members of their clan, of scars and self-adjustements. They are infinitely self-improving, self-experimenting. They might end up with a botched job and have to hobble around for a few days, but in the end it’s always fixable.</p>
<p>And they lisp.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Though, while Elisp is Emacs’s programmability language of choice, the particular language doesn’t matter much. It could be Python, JavaScript, Haskell, whatever. The key is: if most of your feature set is written in your editor’s programming language, then that editor is very programmable.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>


<footer>
  <table style="width:100%">
    <tr>
      <td>© 2013-12-25 <a href="../../">Chris Done</a></td>
      <td style="text-align:right"><a href="../../posts">Read more posts →</a></td>
    </tr>
  </table>
</footer>

    </div>
  </body>
</html>
