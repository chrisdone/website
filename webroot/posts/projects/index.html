<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Projects</title>
    <style>
      body {
      max-width: 40em;
      margin: .5in auto;
      font-size: 18px;
      font-family: serif;
      line-height: 1.5;
      }
      pre, code {
      font-size: 16px;
      word-wrap: break-word;
      }
      pre {
      padding-left: 1em;
      line-height: 1.5em;
      border-left: 5px solid #efefef;
      }
      a {
      color: #1a6e8e
      }
      .menu a {
      margin-right: 1em;
      }
      h1,h2,h3,h4,h5,h6 {
      font-family: Helvetica;
      }

      h1 a,h2 a,h3 a,h4 a {
      text-decoration: none;
      color: inherit;
      }

      .post-1,.post-2{
      margin-bottom: 0.5em;
      }

      .author {
      display: none;
      }

      footer {
      margin-top: 1.5em;
      padding-top: 1.5em;
      border-top: 1px solid #ccc;
      margin-bottom: 2em
      }

      footer span {
      display: none;
      }

      img {
      max-width: 100%
      }
      pre.sourceCode span.st {
      color: #366354
      }
      pre.sourceCode span.kw {
      color: #397460
      }
      pre.sourceCode span.fu {
      color: #8f4e8b
      }
      pre.sourceCode span.ot {
      color: #2e659c
      }
      pre.sourceCode span.dt {
      color: #4F4371
      }
      pre.sourceCode span.co {
      color: #666
      }
      @media(max-width:767px){
      body { margin: 1px 4px; }
      h1, h2, .menu { margin: 0; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.125em; }
      h3 { font-size: 1.0125em; }
      .menu a { margin-right: 0.1em; }
      #archive { margin-left: 1em; margin-top: 0; padding: 0}
      #archive .post-1, #archive .post-2 {
      margin-bottom: 0.1em;
      }
      }
      .footnote-ref { text-decoration: none; }
    </style>
  </head>
  <body>
    <div class="page-wrap">

<h1>Projects</h1>

<p>It might be a “getting old[-er]” thing, but I’ve recently started
feeling like documenting the complete set of software projects I’ve
worked on that I remember. Not as a CV (an advertisement of paid work),
but a comprehensive list of <em>everything</em>.</p>
<p>I’ll start with the old stuff and continuously make updates a little
bit per day. After a few weeks I should be done.</p>
<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#2023">2023</a>
<ul>
<li><a href="#copy-paste-sync">copy-paste-sync</a></li>
<li><a href="#hell">hell</a></li>
</ul></li>
<li><a href="#2021">2021</a>
<ul>
<li><a href="#proclog">proclog</a></li>
<li><a href="#lexx">lexx</a></li>
<li><a href="#hag">hag</a></li>
</ul></li>
<li><a href="#2020">2020</a>
<ul>
<li><a href="#inflex">inflex</a></li>
</ul></li>
<li><a href="#2019">2019</a>
<ul>
<li><a href="#novella">novella</a></li>
<li><a href="#streaming-parsers">streaming-parsers</a></li>
<li><a href="#forge">forge</a></li>
<li><a href="#env-args">env-args</a></li>
<li><a href="#dynamic">dynamic</a></li>
<li><a href="#webshow">webshow</a></li>
</ul></li>
<li><a href="#2018">2018</a>
<ul>
<li><a href="#hex-server">hex-server</a></li>
<li><a href="#sdl2-sprite">sdl2-sprite</a></li>
<li><a href="#caseof">caseof</a></li>
<li><a href="#rocksdb-haskell-ng">rocksdb-haskell-ng</a></li>
<li><a href="#phase">phase</a></li>
<li><a href="#audit">audit</a></li>
<li><a href="#codeparty">codeparty</a></li>
<li><a href="#duta">duta</a></li>
<li><a href="#prana">prana</a></li>
<li><a href="#intero">intero</a></li>
<li><a href="#cron-daemon">cron-daemon</a></li>
</ul></li>
<li><a href="#2017">2017</a>
<ul>
<li><a href="#snappy">snappy</a></li>
<li><a href="#liquid-post">liquid-post</a></li>
<li><a href="#tdiff">tdiff</a></li>
<li><a href="#vado">vado</a></li>
<li><a href="#jl">jl</a></li>
<li><a href="#duet">duet</a></li>
</ul></li>
<li><a href="#2016">2016</a>
<ul>
<li><a href="#purify">purify</a></li>
<li><a href="#labels">labels</a></li>
<li><a href="#org-focus">org-focus</a></li>
</ul></li>
<li><a href="#2015">2015</a>
<ul>
<li><a href="#descriptive">descriptive</a></li>
<li><a href="#stack">stack</a></li>
<li><a href="#path">path</a></li>
<li><a href="#xinput-conduit">xinput-conduit</a></li>
<li><a href="#conditions">conditions</a></li>
<li><a href="#haskell-trace">haskell-trace</a></li>
</ul></li>
<li><a href="#2014">2014</a>
<ul>
<li><a href="#clockin">clockin</a></li>
<li><a href="#present">present</a></li>
<li><a href="#ace">ace</a></li>
<li><a href="#hl">hl</a></li>
<li><a href="#formatting">formatting</a></li>
<li><a href="#hindent">hindent</a></li>
<li><a href="#foreign-store">foreign-store</a></li>
<li><a href="#shell-conduit">shell-conduit</a></li>
<li><a href="#lucid">lucid</a></li>
<li><a href="#wrap">wrap</a></li>
<li><a href="#gmail">gmail</a></li>
<li><a href="#osdkeys">osdkeys</a></li>
<li><a href="#keyboard-stats">keyboard-stats</a></li>
<li><a href="#ghc-server">ghc-server</a></li>
<li><a href="#ats-examples">ats-examples</a></li>
<li><a href="#carvo">carvo</a></li>
</ul></li>
<li><a href="#2013">2013</a>
<ul>
<li><a href="#ini">ini</a></li>
<li><a href="#pure-io">pure-io</a></li>
<li><a href="#god-mode">god-mode</a></li>
<li><a href="#structured-haskell-mode">structured-haskell-mode</a></li>
<li><a href="#haskellnews">haskellnews</a></li>
<li><a href="#ircbrowse">ircbrowse</a></li>
<li><a href="#snap-app">snap-app</a></li>
<li><a href="#cabal-sign">cabal-sign</a></li>
</ul></li>
<li><a href="#2012">2012</a>
<ul>
<li><a href="#sourcemap">sourcemap</a></li>
<li><a href="#fay">fay</a></li>
<li><a href="#scrobble">scrobble</a></li>
<li><a href="#bdo">bdo</a></li>
</ul></li>
<li><a href="#2011">2011</a>
<ul>
<li><a href="#pdfinfo">pdfinfo</a></li>
<li><a href="#chrisdone-xmonad">chrisdone-xmonad</a></li>
<li><a href="#flo">flo</a></li>
<li><a href="#freenect">freenect</a></li>
<li><a href="#hulk">hulk</a></li>
<li><a href="#ji">ji</a></li>
<li><a href="#pgsql-simple">pgsql-simple</a></li>
<li><a href="#css">css</a></li>
<li><a href="#url-generic">url-generic</a></li>
<li><a href="#hog">hog</a></li>
</ul></li>
<li><a href="#2010">2010</a>
<ul>
<li><a href="#tryhaskell">tryhaskell</a></li>
<li><a href="#jquery-console">jquery-console</a></li>
<li><a href="#lisk">lisk</a></li>
</ul></li>
<li><a href="#2009">2009</a>
<ul>
<li><a href="#asp-mode">asp-mode</a></li>
</ul></li>
<li><a href="#2008">2008</a>
<ul>
<li><a href="#kibro">kibro</a></li>
<li><a href="#lojbot">lojbot</a></li>
</ul></li>
<li><a href="#2006">2006</a>
<ul>
<li><a href="#slsksoulski">slsk/soulski</a></li>
<li><a href="#wdn">wdn</a></li>
</ul></li>
</ul>
<!-- markdown-toc end -->
<h1 id="section">2023</h1>
<h2 id="copy-paste-sync">copy-paste-sync</h2>
<p>I wrote this trivial tool called <a
href="https://github.com/chrisdone-archive/copy-paste-sync">copy-paste-sync</a>
that can copy/paste between systems by always keeping the clipboard in
sync. It basically just watches the clipboard for changes and then POSTs
the content to interested parties. At work I use a MacBook, but I also
have my Linux laptop next to it, so being able to copy/paste between the
two is handy.</p>
<h2 id="hell">hell</h2>
<p><a href="https://github.com/chrisdone/hell">Hell</a> is a shell
scripting language that is a tiny dialect of Haskell that I wrote for my
own shell scripting purposes. Full blog post about it <a
href="https://chrisdone.com/posts/hell/">here.</a></p>
<h1 id="section-1">2022</h1>
<h2 id="envy">envy</h2>
<p>I found myself using tools that want to control my shell environment
at work in order to run commands properly. This makes it annoying to
simply run a command from Emacs. So I wrote a mini tool called <a
href="https://github.com/chrisdone-archive/envy">envy</a> that simply
saves the environment generated by such a tooling setup, and then
execute any command with the same environment later.</p>
<h1 id="section-2">2021</h1>
<h2 id="proclog">proclog</h2>
<p>While consulting on a project that ran executables deeply within it,
I wrote <a
href="https://github.com/chrisdone-archive/proclog">proclog</a> as a
kind of ‘smarter tee’. I haven’t used this for a while and it isn’t
maintained anymore, but it was handy in the moment.</p>
<h2 id="lexx">lexx</h2>
<p>I wrote a project called <a
href="https://github.com/chrisdone-archive/lexx">lexx</a>, which lexes
Haskell code, specifically <code>Show</code> instances, but it can
handle fairly unstructured input, and still pretty print it with colours
nicely. It’s good for dev logs or general pretty printers.</p>
<h2 id="hag">hag</h2>
<p>I fiddled about with a project called <a
href="https://github.com/chrisdone-archive/hag">hag</a>, “Haskell ag”,
which would let one “grep” Haskell files for identifiers, and exclude
strings, comments, etc. by lexing them properly. I haven’t used this for
a while, it’s currently in the freezer.</p>
<h1 id="section-3">2020</h1>
<h2 id="inflex">inflex</h2>
<p>This was my dream project that I planned on being The Big One for my
30s. It involves all my skills: web, services, parsers, type checkers,
interpreters, UI, etc. I had a business, a registered trademark, lawyers
draft up Ts&amp;Cs and a privacy policy, accountant, Stripe account,
etc. It was going to be an online spreadsheet competitor. <a
href="https://chrisdone.com/posts/inflex/">Inflex</a> was going to be a
big hit.</p>
<p>I had a kid and then it took a back seat, I couldn’t financially
justify paying an accountant and for all the services when I only had an
hour a week to dabble in it. So I packed it in.</p>
<p>However, it has some of my best work. The compiler pipeline is
beautiful. Some of the implementation is wonderful. The design
trade-offs are brilliant and I researched everything over 2 years. The
<a href="https://github.com/chrisdone-archive/inflex">archive repo is
here</a>.</p>
<!-- ## early -->
<h1 id="section-4">2019</h1>
<h2 id="novella">novella</h2>
<p>For some bizarre reason, I thought it would be a good idea to make a
structured editor in the terminal called <a
href="https://github.com/chrisdone-archive/novella">novella</a>: the big
idea was to define a simple grammar for any language and get a
structured editor out of it, like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">grammar ::</span> <span class="dt">Grammar</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>grammar <span class="ot">=</span> <span class="op">$</span>(checkGrammar <span class="op">$</span> runDefine <span class="op">$</span> mdo</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- General expression</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  expression       <span class="ot">&lt;-</span> rule <span class="st">&quot;Expression&quot;</span> (<span class="dt">ChoiceSchema</span> [variable, constructor, parentheses</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                                                      ,tuple, let&#39;, application, string])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  application      <span class="ot">&lt;-</span> rule <span class="st">&quot;Application&quot;</span> (<span class="dt">CompositeSchema</span> [expression, expression])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  parentheses      <span class="ot">&lt;-</span> rule <span class="st">&quot;Parentheses&quot;</span> (<span class="dt">CompositeSchema</span> [openParenSchema, expression, closeParenSchema])</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Tuple</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  tuple            <span class="ot">&lt;-</span> rule <span class="st">&quot;Tuple&quot;</span> (<span class="dt">CompositeSchema</span> [openParenSchema, tupleElements, closeParenSchema])</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  tupleElements    <span class="ot">&lt;-</span> rule <span class="st">&quot;Tuple elements&quot;</span> (<span class="dt">ListSchema</span> expression <span class="st">&quot;,&quot;</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Identifiers</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  variable         <span class="ot">&lt;-</span> rule <span class="st">&quot;Variable&quot;</span> (<span class="dt">IdentifierSchema</span> <span class="st">&quot;Variable&quot;</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  constructor      <span class="ot">&lt;-</span> rule <span class="st">&quot;Constructor&quot;</span> (<span class="dt">IdentifierSchema</span> <span class="st">&quot;Constructor&quot;</span>)</span></code></pre></div>
<h2 id="streaming-parsers">streaming-parsers</h2>
<p>I wrote, along with Michael Snoyman, some streaming JSON/YAML
parsers, in a package I called <a
href="https://github.com/chrisdone-archive/streaming-parsers">streaming-parsers</a>,
with the express intent to avoid security issues implied by packages
like <code>aeson</code> which consume the whole input given by the user.
This package never got used, but I did end up using
<code>reparsec</code> elsewhere, which was like a parsec that streams
like attoparsec, but works on any token rather than Text/ByteString.
Arguably megaparsec fits that niche these days, although I find
megaparsec kind of awkward and I can never remember how to use it.</p>
<h2 id="forge">forge</h2>
<p>I wrote <a
href="https://github.com/chrisdone-archive/forge">forge</a> as my answer
to modernizing formlets,<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> after the world forgot about
multi-page web apps and switched to frontend/backend stratification.</p>
<p>However, it introduces a few novel ideas:</p>
<ul>
<li>Static checking of the uniqueness of names within a form</li>
<li>Errors can go both up <em>and</em> down in the form, meaning you can
“send” a validation error from above down to the input that caused
it</li>
<li>Selective-like behavior</li>
<li>Typed handling of optional vs required fields, which in other
libraries is a bit wishy-washy</li>
</ul>
<h2 id="vado">vado</h2>
<p><a href="https://github.com/chrisdone-archive/vado">Vado</a> is a
demonstration program that is able to load a web page up and render it
like in the early 90’s. It supports laying out text, different font
sizes for headings, inline and block elements, hyperlinks, bold and
italics. It supports mousewheel scrolling, too.</p>
<p>I wrote this in a couple evenings, because it seemed straight-forward
to do so given the libraries available at the time. Also, there’s an
inarticulate gut feeling I have that tells me maybe it’s worth
celebrating these days in which the web is still viewable in its
simplest, earliest form.</p>
<h2 id="env-args">env-args</h2>
<p>A simple tool called <a
href="https://github.com/chrisdone-archive/env-args">env-args</a> that
would convert environment variables to program arguments. With this, it
became trivial to either pass –foo arguments or PROGRAM_FOO variables.
Used for a client.</p>
<h2 id="dynamic">dynamic</h2>
<p>Partly as a joke, partly serious, I made a package called <a
href="https://github.com/chrisdone-archive/dynamic">dynamic</a> which
gives you dynamic types in Haskell. It makes it trivial to explore
unknown data in Haskell. I’ve never used it, but in principal it is
interesting.</p>
<h2 id="webshow">webshow</h2>
<p>I made a simple tool to generate a hierchical data structure browser
for Haskell <code>Show</code> output (similar to <a
href="#present">present</a>), and called it <a
href="https://github.com/chrisdone-archive/webshow">webshow</a>. I have
occasionallly resurrected this, when I need to explore really hairy
Haskell data structures.</p>
<h1 id="section-5">2018</h1>
<h2 id="hex-server">hex-server</h2>
<p>I can’t explain some of the motivations for my projects. I wrote <a
href="https://github.com/chrisdone-archive/hex-server">hex-server</a>
which was a ground-up implementation of Xorg-server in Haskell. I have
no idea why. Curiosity, I guess.</p>
<h2 id="sdl2-sprite">sdl2-sprite</h2>
<p>I was fiddling about with sdl2 at this time. <a
href="https://github.com/chrisdone-archive/sdl2-sprite">sdl2-sprite</a>
just repeats a sprite for you (see the README gif). I think there are
other tools around for this, but I found this one just did exactly what
I wanted while making a sprite in InkScape.</p>
<h2 id="caseof">caseof</h2>
<p>The <a href="https://github.com/chrisdone-archive/caseof">caseof</a>
package is just a proof of concept to test whether I could avoid lens
and get what I wanted: trivially ask whether a value is of a particular
constructor and if so, return a <code>Maybe</code> of the slots. Answer
is: yes, you can. Does anyone use it? No, lens is too popular.</p>
<h2 id="rocksdb-haskell-ng">rocksdb-haskell-ng</h2>
<p><a
href="https://github.com/chrisdone-archive/rocksdb-haskell-ng">rocksdb-haskell-ng</a>
was needed for some cryptocurrency client, who were inadvisedly using
rocksdb, in Haskell, and the existing package was, well, neither stable
or efficient. I rewrote it from scratch, with stability and performance
in mind. I’m quite proud of the work I did on this, it was good
work.</p>
<h2 id="phase">phase</h2>
<p>Another case of having too much time on my hands perhaps. <a
href="https://github.com/chrisdone-archive/phase">phase</a> basically
provides a frontend to Emacs in your browser. It’s not as native as the
GTK or terminal frontends, but the latency wasn’t too bad. I’m not sure
I’ll ever pick this up again. But it was surprisingly usable.</p>
<h2 id="audit">audit</h2>
<p>I had to audit a number of projects at FP Complete. This <a
href="https://github.com/chrisdone-archive/audit">emacs mode</a> helped
me interactively mark any selection of any file as viewed, accepted or
problematic, with comments. I would still use this today if I need to
audit or heavily review a project.</p>
<h2 id="codeparty">codeparty</h2>
<p>When teaching Haskell to companies at FP Complete, it was handy to
have everyone type out the answer to an exercise live on screen. For
that I made <a
href="https://github.com/chrisdone-archive/codeparty">codeparty</a>,
which was a bit like a mass screen share, but more efficient, and
ensured everyone had the same editing experience. I would use this again
if I needed to teach Haskell again.</p>
<h2 id="duta">duta</h2>
<p>I wrote my own email server called <a
href="https://github.com/chrisdone-archive/duta">duta</a>, which was
about being able to self-host email. I actually ran it for years; it was
only because LetsEncrypt at the time was harder to use and required
upgrades and maintenance that I gave up on it, but for a while I was
reading my mail with my own Haskell-made email web and Emacs client.</p>
<h2 id="prana">prana</h2>
<p>I was really into the idea of being able to interpret Haskell within
Haskell, so I made a project called <a
href="https://github.com/chrisdone-archive/prana">prana</a> which would
compile GHC Haskell down to STG, convert that STG to an internal format,
and then interpret it. It turns out, there are quite a few “implicit”
things in STG that you just have to know, figure out or ask around
about. The GHC internals change far too often, so I gave up on this. But
I took a good crack at it.</p>
<h2 id="intero">intero</h2>
<p><a href="https://github.com/chrisdone-archive/intero">intero</a> was
my “complete” (<em>intero</em> is Italian for ‘whole’) Haskell IDE in
Emacs. I was given space at FP Complete to work on it as a product to
solve the whole Haskell tooling issue. It was actually a brilliant
project, and worked on almost everything, and rarely if ever broke.
There was a lot of Emacs Lisp, and a modicum of Haskell in a GHCi fork I
called <code>intero</code>.</p>
<p>Some of that Elisp still lives on in my Emacs config, but the project
itself I sunsetted some years ago after I was subjected to one final GHC
upgrade and could not bare to port my code over to yet another GHC API
API change. I just gave up.</p>
<p>But on the whole it was a great project and had 1k users at
least.</p>
<h2 id="cron-daemon">cron-daemon</h2>
<p>I wanted a handy way to have a ‘service’ run and re-run easily, which
I called <a
href="https://github.com/chrisdone-archive/cron-daemon">cron-daemon</a>.
This was my first tool that I statically built with musl. I haven’t used
this for a while, but I might use it in the future. It can be used in
combination with
<code>stack build --file-watch --exec 'cron-daemon ..'</code> to cause a
service to restart after recompiling.</p>
<h1 id="section-6">2017</h1>
<h2 id="snappy">snappy</h2>
<p>A brief experiment called <a
href="https://github.com/chrisdone-archive/snappy">snappy</a> to try out
Reflex-like FRP with SVG. It’s not as easy as you think to do this, and
there are all sorts of gotchas. Where possible, don’t DIY FRP. It’s
hard.</p>
<h2 id="liquid-post">liquid-post</h2>
<p>I wrote a post about Liquid Haskell for FP Complete, but <a
href="https://github.com/chrisdone-archive/liquid-post">this repo</a>
shows all the examples and they are quite good, I think.</p>
<h2 id="tdiff">tdiff</h2>
<p>I still use this sometimes. <a
href="https://github.com/chrisdone-archive/tdiff">tdiff</a> just gives
you timing between lines of output from a process. This can be really
good for checking timings of other programs than your own.</p>
<h2 id="vado-1">vado</h2>
<p>In an exhibition of sorts, I made a 90s-style web browser called <a
href="https://github.com/chrisdone-archive/vado">vado</a> (“I go” in
Italian), which can show rich text documents and browse around. I think
it’s pretty cool that I was able to do this in a few hundred lines of
code, and it works/worked on Windows, macOS and Linux, too!</p>
<h2 id="jl">jl</h2>
<p>I like <code>jq</code> a bit, but I always found myself just wishing
I had a basic mini lambda calculus/Haskell. So I wrote a small
statically typed mini language called <a
href="https://github.com/chrisdone-archive/jl">jl</a>. I used it for a
while, but somehow I’ve managed to go years and years without needing to
do JSON munging in scripts or anything. So this project died due to lack
of use. I otherwise think the design and implementation are both
good.</p>
<h2 id="duet">duet</h2>
<p>I have no idea why I started working on this, but I wrote a <a
href="https://github.com/chrisdone-archive/duet">small Haskell
implementation</a> called Duet, which is helpful for teaching because it
has a substitution-based interpreter. It was based on Typing Haskell in
Haskell, which was refactored a bit, more types added, etc. It’s quite a
viable Haskell implementation. Great for teaching.</p>
<p>I never found other uses for it, because frankly I don’t fully
understand the type-checker, because I didn’t author it from scratch.
Future projects involved writing one from scratch, which I do
understand. See <a href="#inflex">Inflex</a> or <a
href="#hell">Hell</a>.</p>
<!-- ## xeno -->
<h1 id="section-7">2016</h1>
<h2 id="purify">purify</h2>
<p>I was doing more PureScript dev in 2016, so I made <a
href="https://github.com/chrisdone-archive/purify">purify</a>, which was
basically stackage+stack, but for PureScript. It was popular for a
while, but then the main PureScript package manager gained these
capabilities and it wasn’t necessary anymore. But it was a solid
project, I think.</p>
<h2 id="labels">labels</h2>
<p>As part of proving out whether Haskell could really be useful as a
data analysis language (answer: not really), I wrote <a
href="https://github.com/chrisdone-archive/labels">labels</a>, which is
an extensible records package, along with CSV, JSON capabilities. It
worked, actually, but nothing much came of it after that.</p>
<h2 id="org-focus">org-focus</h2>
<p>In an effort to track all my time on projects, I wrote <a
href="https://github.com/chrisdone-archive/org-focus">org-focus</a> for
Emacs. It was a bit like org-agenda, but included time spent, estimates,
and stuff that a consultant might need. I don’t track my time with such
fine-grain detail these days, so I stopped using it.</p>
<h1 id="section-8">2015</h1>
<h2 id="descriptive">descriptive</h2>
<p>I noticed that optparse-applicative, formlets, yaml/json parsing,
etc. were all a type of self-describing parser. Hence <a
href="https://github.com/chrisdone-archive/descriptive">descriptive</a>.
I think the task of generalizing all of these under one framework is
harder than I anticipated, despite the grand vision, and the project
died.</p>
<h2 id="stack">stack</h2>
<p>At FP Complete, clients wanted a tool that covered all their
use-cases, which typically involved multi-package projects and wanting
to avoid the cabal solver. Motivated by previous success with internal
tools,<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> we decided to make a proper tool and
decided the name would be ‘stack’ (from stackage). I made <a
href="https://github.com/chrisdone-archive/stack/commit/cb95f21855e23c715a106bb484b307623529e323">the
first commit for Stack</a>. I worked on it for a year or two, alongside
many people at FP Complete like Michael Sloan, Manny Borsboom, Dan
Burton and Michael Snoyman, and I have used it ever since. Most everyone
else did the bulk of the work, I only kick started the basics (reading
cabal files, GHCi support, things like that).</p>
<p>The first version used Shake, but we discovered it was very hard to
reason about what it was doing. Michael rewrote the scheduler to not
need Shake, and did further work to basically make Stack a bit like Nix
and lock down all packages, package sets into with SHA256 hashes. I
wrote <a href="https://casa.stackage.org/">casa.stackage.org</a> to
store content-addressed blobs of package files for Stack to later
retrieve.</p>
<p>It went on to become the build tool of choice for Haskell projects
for some years. It’s only in recent years that cabal-install has caught
up with feature parity and the sentiment seems to be shifting back to
cabal-install. I still use stack because the ergonomics are more
designed for my workflow.</p>
<h2 id="path">path</h2>
<p>As part of my work on stack, we deal with filepaths a lot, so I wrote
the <a href="https://github.com/chrisdone-archive/path">path
package</a>, <a href="https://chrisdone.com/posts/path-package/">with a
blog post motivating it</a>. I was pretty happy with this package, it
solved a real need that initially a lot of people were sceptical of, but
colleagues told me it saved their asses a few times.</p>
<p>That package is still maintained to my knowledge.</p>
<h2 id="xinput-conduit">xinput-conduit</h2>
<p><a
href="https://github.com/chrisdone-archive/xinput-conduit">This</a>
package simply converts the <code>xinput</code> output (which yields all
keys pressed in Xorg), and provides them as a Haskell source conduit. I
was using it for keypress analysis back then. I still think it’s a nifty
trick.</p>
<h2 id="conditions">conditions</h2>
<p>Conditions are a Common Lisp idea. Unlike exceptions which unwind the
stack, they call a function which is bound in the dynamic scope, which
gives the option of providing a different value for the calling code to
use. There are whole workflows built around them in Lisp. You can be
reading from a bunch of files in a loop, encounter a problem, fix it,
and then continue running the program.</p>
<p>I was inspired to demonstrate that <a
href="https://github.com/chrisdone-archive/conditions">in Haskell.</a>
But it’s not as good as in Lisp, which embraces it fully.</p>
<h2 id="haskell-trace">haskell-trace</h2>
<p>I wrote <a
href="https://github.com/chrisdone-archive/haskell-trace">a small
tool</a> to add trace calls in one’s Haskell code. This is something
that Haskell sorely lacks, and I can’t see acquiring any time soon.</p>
<h1 id="section-9">2014</h1>
<h2 id="clockin">clockin</h2>
<p>I wrote <a
href="https://github.com/chrisdone-archive/clockin">clockin</a> as a
command-line app to be able to clockin and clockout of any task. I used
this for a while, maybe a year, before losing interest in clocking my
time so accurately.</p>
<h2 id="present">present</h2>
<p>After looking at CLIM (Common Lisp Interface Manager), I really liked
the idea of being able to <em>present</em> a value with multiple
interpretations. That’s what <a
href="https://github.com/chrisdone-archive/present">present</a> was
about. I used template-haskell to inspect any type and derive a
representation for it. Even <code>ByteString</code> had multiple views,
e.g. as a list of bytes, as UTF-8 text, hex, a pointer, etc.</p>
<p>I kind of ran myself into the ground with this when it came to higher
kinded types. I got stuck and lost interest. I would love to pick it up
again some day.</p>
<h2 id="ace">ace</h2>
<p>In the afterglow of growing bored of Lojban, but still enamoured by
formal human languages, I got into Attempto (Latin for ‘I dare’)
Controlled English. I ended up writing a parser package for it in
Haskell <a href="https://github.com/chrisdone-archive/ace">here</a>.
It’s surprisingly comprehensive, I wrote <a
href="https://chrisdone.com/posts/attempto-controlled-english/">a blog
post on it</a>. It even permits passing a record of parsers, permitting
the user to define their own vocabulary and syntax for terms.</p>
<p>When I wrote it, use of such things was questionable. Combine it with
a logic database and <em>poof</em>, magic understanding! In reality, not
quite. Arguably, the use for such a thing in today’s brave new world of
LLMs is even more questionable.</p>
<p>But I suppose there still lies a small place in my heart for a formal
language that is also readable by anyone who speaks English.</p>
<h2 id="hl">hl</h2>
<p>The Haskell web site has already been a bit crap. Today, it’s okay.
It’s been much worse. During that period of much-worseness, I wrote <a
href="https://github.com/chrisdone-archive/hl">hl</a>, an alternative
Haskell homepage, complete with <a
href="https://chrisdone.com/posts/haskell-lang/">reasoning</a>, which I
launched at haskell-lang.org as an alternative competing page, due to
making no progress at all for years in trying to get access to
haskell.org itself. Eventually, it did become the Haskell homepage due
to some diplomatic heroics. In that sense, I suppose the project was a
success. There was, as expected, lots of politics surrounding it, but
that’s always the case with home pages of community projects.</p>
<h2 id="formatting">formatting</h2>
<p>I thought that the <a
href="https://hackage.haskell.org/package/HoleyMonoid">HoleyMonoid</a>
package was very neat, and decided it would make a perfect type-safe
printf-like package. I called it <a
href="https://github.com/chrisdone-archive/formatting">formatting</a>,
after Common Lisp’s FORMAT.</p>
<p>Actually, it turned out that despite the neat trick, I really doing
like the position-dependent style of printf/FORMAT at all. I prefer just
writing <code>x &lt;&gt; " and " &lt;&gt; y</code> instead, or
<code>concat [x, "and", y]</code>. So the whole thing became an
experiment in novelty, but ultimately I lost interest and passed the
maintainership onto someone else.</p>
<h2 id="hindent">hindent</h2>
<p><a href="https://github.com/chrisdone-archive/hindent">hindent</a>
was my bold attempt to make a complete pretty printer for Haskell, so
that manual code formatting would be a thing of the past. This was quite
a substantial project and took a lot of work. <a
href="https://chrisdone.com/posts/hindent/">The blog post</a> explains
the motivations, but I just wanted to type less and get autoformatting.
I later went one step further and limited it to a single style (which is
what gofmt famously did), which I documented <a
href="https://chrisdone.com/posts/hindent-5/">here</a>. I even chose a
style that I didn’t like, but that was popular. The decision to enforce
just one style made a lot of people mad.</p>
<p>Years later, there was a remake project called Ormolu<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>,
which also enforced one style. There was subsequently a fork called
Fourmolu, which permitted more style configuration.<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<h2 id="foreign-store">foreign-store</h2>
<p>The <a
href="https://github.com/chrisdone-archive/foreign-store">foreign-store</a>
package is a simple bit of C code wrapped in a Haskell package that lets
you keep a reference to a Haskell object between GHCi reloads, which I
wrote <a href="https://chrisdone.com/posts/ghci-reload/">for the purpose
of hot reloading.</a> It’s actually still used to this day and
maintained by someone else. There are 12 direct dependencies of it on
Hackage, mostly various different ways of doing code reloading.<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a> They’re all fancy wrappers around
this.</p>
<p>10 years after it had been published and not been touched for just as
long, someone found and fixed a segfaulting bug in the C code. Can you
believe it?</p>
<h2 id="shell-conduit">shell-conduit</h2>
<p>I’ve been wanted to write shell scripts since 2014. This attempt, <a
href="https://github.com/chrisdone-archive/shell-conduit">shell-conduit</a>,
was to get all available names in the <code>PATH</code>, available as
real Haskell identifiers to run. And then “scripts” would be regular
Haskell programs.</p>
<p>I’ve since changed my mind that this is a good idea, and see above
for the <a href="#hell">Hell</a> project.</p>
<h2 id="lucid">lucid</h2>
<p><a href="https://github.com/chrisdone/lucid">Lucid</a> is still
actively developed, and was motivated by have a uniformity of
combinators, like HTML handling in Common Lisp.</p>
<p>It’s also a proper monad transformer, which has a small theoretical
satisfaction to it.</p>
<p>It’s one of my projects that is using the <a
href="https://chrisdone.com/posts/ipp/">Immutable Publishing
Policy</a>.</p>
<h2 id="wrap">wrap</h2>
<p>https://github.com/chrisdone-archive/wrap</p>
<h2 id="gmail">gmail</h2>
<p>https://github.com/chrisdone-archive/gmail</p>
<h2 id="osdkeys">osdkeys</h2>
<p>https://github.com/chrisdone-archive/osdkeys</p>
<h2 id="keyboard-stats">keyboard-stats</h2>
<p>https://github.com/chrisdone-archive/keyboard-stats</p>
<h2 id="ghc-server">ghc-server</h2>
<p>https://github.com/chrisdone-archive/ghc-server</p>
<h2 id="ats-examples">ats-examples</h2>
<p>https://github.com/chrisdone-archive/ats-examples</p>
<h2 id="carvo">carvo</h2>
<p>https://github.com/chrisdone-archive/carvo</p>
<h1 id="section-10">2013</h1>
<h2 id="ini">ini</h2>
<p>Back before YAML took over, there wasn’t a winning configuration
format. XML had lost its lustre. So I wrote <a
href="https://github.com/chrisdone-archive/ini/">ini</a>, which parsed
the simple INI format.</p>
<p>Since, YAML is now de-facto standard (although TOML is floating
around), so I stopped using this.</p>
<h2 id="pure-io">pure-io</h2>
<p>A small project called <a
href="https://github.com/chrisdone-archive/pure-io">pure-io</a> that
provided a little IO monad that would run as a pure function. I used
this for tryhaskell.org.</p>
<h2 id="god-mode">god-mode</h2>
<p>After suffering from RSI for a while, I had decided with Emacs I’d
look at my typing with statistics. After a week or so of full day typing
every day, I found that I made a significant proportion of key chords in
succession. I evaluated vim modes and realised that they depart from
Emacs quite a bit or lacked a story for many modes. In the end I had the
thought to make the Ctrl implicitly on all the time, and this turned out
to be undeniably productive and practical in the form of <a
href="https://github.com/chrisdone-archive/god-mode">god-mode</a>.</p>
<p>I’m still using it to this day, although it has been folded into my
Emacs config.</p>
<h2 id="structured-haskell-mode">structured-haskell-mode</h2>
<p>In similar themes to god-mode, I made a structured editor for Emacs’s
haskell-mode that would essentially let one edit Haskell code like
paredit. That used a Haskell parser via haskell-src-exts, and produced a
set of s-expressions for Emacs to convert to a set of markers. The minor
mode was called <a
href="https://github.com/chrisdone-archive/structured-haskell-mode">structured-haskell-mode</a>.</p>
<h2 id="haskellnews">haskellnews</h2>
<p><a
href="https://github.com/chrisdone-archive/haskellnews">haskellnews</a>
was a simple web app to list all the sources of blogs, posts, tweets,
etc. about Haskell. I sort of lost interest in social Mead and therefore
stopped running it. But for a while I enjoyed using it.</p>
<h2 id="ircbrowse">ircbrowse</h2>
<p>I wrote <a
href="https://github.com/chrisdone-archive/ircbrowse">ircbrowse</a> at
ircbrowse.net to be a replacement to the much older ircbrowse.com.</p>
<p>ircbrowse.com was a great web site for browsing chat logs of various
IRC channels, it was also infamously slow as hell. So a fundamental
motivator was to make something that would be instant, and I succeeded
on that, much to my personal pride.</p>
<p>It could handle about 30 million lines of chat across a few channels
for about 10 years of logs. There were something in the order of 30k
lines of chat from the #haskell channel per month.</p>
<p>I stopped running it after I lost interest in IRC, but it was a very
satisfying project and I learned a lot about PostgreSQL’s performance
characteristics in the process.</p>
<h2 id="snap-app">snap-app</h2>
<p>https://github.com/chrisdone-archive/snap-app</p>
<h2 id="cabal-sign">cabal-sign</h2>
<p>https://github.com/chrisdone-archive/cabal-sign</p>
<h1 id="section-11">2012</h1>
<h2 id="sourcemap">sourcemap</h2>
<p>For <a href="#fay">fay</a>, I thought it’d be good to include <a
href="https://github.com/chrisdone-archive/sourcemap">sourcemaps</a>, so
I wrote this package as a more or less line-by-line translation of the
reference implementation. The spec itself was very informal. It worked,
though, and performed fairly well.</p>
<h2 id="fay">fay</h2>
<p>I wrote a language called Fay, which was a Haskell without
type-classes that compiled to JavaScript, and used GHC’s type system for
the type-checking.</p>
<p>It ended up being quite popular, it garnered its own <a
href="https://github.com/faylang/">organisation</a>, and I had a
co-maintainer called Adam Bergmark, who was very nice and smart.<a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a></p>
<p>I was invited to and went to a conference in Lisbon to give a talk on
it.</p>
<p>FP Complete used it for their IDE which was a web based Haskell IDE,
which is pretty much how I got the job at FP Complete in 2013. A couple
years or so later, after the IDE project petered out, we stopped using
it. There were better options by then (PureScript, etc.).<a href="#fn7"
class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<ul>
<li><a href="/posts/fay">Blog post</a></li>
</ul>
<h2 id="scrobble">scrobble</h2>
<p>https://github.com/chrisdone-archive/scrobble</p>
<h2 id="bdo">bdo</h2>
<p>https://github.com/chrisdone-archive/bdo</p>
<h1 id="section-12">2011</h1>
<h2 id="pdfinfo">pdfinfo</h2>
<p>This <a
href="https://github.com/chrisdone-archive/pdfinfo">utility</a> package
just launches pdfinfo and parses the output. I needed it for work at the
time.</p>
<h2 id="chrisdone-xmonad">chrisdone-xmonad</h2>
<p>I was using xmonad in 2011, hence <a
href="https://github.com/chrisdone-archive/chrisdone-xmonad">my
config</a> of course was published on GitHub. Like your Emacs config,
it’s traditional to publish your XMonad. I don’t use tiling window
managers anymore. But XMonad is a good one.</p>
<h2 id="flo">flo</h2>
<p>I wrote a small tool that would let you annotate your source code and
project a flow diagram, called <a
href="https://github.com/chrisdone-archive/flo">flo</a>. This could
still be used today with relative ease, I think. It’s language-agnostic.
I never advertised it, though.</p>
<h2 id="freenect">freenect</h2>
<p>I bought a Kinect, which was Microsoft’s XBox
camera/infra-red-distance viewer hardware. There were C libs, so I wrote
Haskell bindings to it and called it <a
href="https://github.com/chrisdone-archive/freenect">freenect</a>. There
were some fun things I made with it.</p>
<h2 id="hulk">hulk</h2>
<p>I wrote an IRC server for use at work for us to chat on. We used it
for some years after we all left, until we eventually migrated to an app
called Wire (also written in Haskell).</p>
<p>This was my first proper experience using threading in Haskell and
working on a sockets server in Haskell. I would note that architecting
an IRC server in a nice way remains an unsolved problem in my head. In
any language.</p>
<ul>
<li><a href="https://github.com/chrisdone-archive/hulk">GitHub
archive</a></li>
<li><a href="/posts/hulk-haskell-irc-server">Blog post</a></li>
</ul>
<h2 id="ji">ji</h2>
<p>I wrote a library called <a href="/posts/ji-haskell-web/">Ji</a>,
which is a simple concept to write a web app in Haskell that sends
commands to a browser of what DOM changes to make and what events to
listen to.</p>
<p>It was taken over by Heinrich Apfelmus and renamed to <a
href="https://github.com/HeinrichApfelmus/threepenny-gui">threepenny-gui</a>,
after which he added many FRP-based things and has likely rewritten all
of it by this point.</p>
<h2 id="pgsql-simple">pgsql-simple</h2>
<p>https://github.com/chrisdone-archive/pgsql-simple</p>
<h2 id="css">css</h2>
<p>https://github.com/chrisdone-archive/css</p>
<h2 id="url-generic">url-generic</h2>
<p>https://github.com/chrisdone-archive/url-generic</p>
<h2 id="hog">hog</h2>
<p>https://github.com/chrisdone-archive/hog</p>
<h1 id="section-13">2010</h1>
<h2 id="tryhaskell">tryhaskell</h2>
<p><a href="https://tryhaskell.org/">tryhaskell.org</a></p>
<p>This was a big splash when I made it, it hit the top of some big
subreddits and Hacker News. It was inspired by tryruby.org, which was
made by _whytheluckystiff, the mysterious Rubyist who disappeared from
the community. It runs you through an interactive tutorial about Haskell
basics and checks your answers.</p>
<p>I’ve been meaning to rewrite this one day, but so far haven’t been
sufficiently inspired to do so.</p>
<p>It’s been running for 14 years, which is quite a long time.</p>
<h2 id="jquery-console">jquery-console</h2>
<p>Written for Try Haskell, this is <a
href="https://github.com/chrisdone-archive/jquery-console">was</a> dumb
terminal/console-like experience in the browser using JQuery. It still
works correctly to this day, on tablets, phones and computers. I stopped
maintaining it as a separate package years and years ago, but tryhaskell
still works fine.</p>
<h2 id="lisk">lisk</h2>
<p>I had enough hubris to think I would be able to write a Lisp syntax
on top of Haskell, and called it <a
href="/posts/lisk-lisp-haskell">Lisk</a>.</p>
<p>I was happy with Haskell, but bummed out by its syntax compared to
the beauty of Lisp. That hasn’t changed today in 2024.</p>
<ul>
<li><a href="https://github.com/chrisdone-archive/lisk">GitHub
archive</a></li>
</ul>
<h1 id="section-14">2009</h1>
<h2 id="asp-mode">asp-mode</h2>
<p>https://github.com/chrisdone-archive/asp-mode</p>
<h1 id="section-15">2008</h1>
<h2 id="kibro">kibro</h2>
<p>In 2008 I was working for a small sum on a hair salon’s new web site,
in Haskell. And I made a very trivial web library called “Kibro” (from
the Lojban “cyberspace”), which sat upon CGI and could be ran from PHP,
which is how I was running it.</p>
<ul>
<li>Source code archive: <a
href="/archives/2008/kibro-0.5.0.tar.gz">kibro-0.5.0.tar.gz</a></li>
<li>Other links: <a
href="https://chrisdone.com/posts/kibro-refactoring/">Kibro
refactoring</a></li>
</ul>
<h2 id="lojbot">lojbot</h2>
<p>Around this time I was an enthusiastic Lojban hobbyist, so I wrote an
IRC bot with various capabilities.</p>
<ul>
<li><a href="https://github.com/chrisdone-archive/lojbot">GitHub
archive</a></li>
<li><a href="https://chrisdone.com/posts/lojbot/">Blog post</a></li>
</ul>
<h1 id="section-16">2006</h1>
<h2 id="slsksoulski">slsk/soulski</h2>
<p>A project for the Soulseek music sharing network. Web site, which may
not remain long-term: <a
href="https://slsk.sourceforge.net/">slsk.sourceforge.net</a>.
Amusingly, it still looks great. <a
href="/images/blog/slsk-screenshot-2007.png">Here’s a screenshot.</a> <a
href="/images/blog/slsk.jpeg">Another</a>. I started writing a C library
for Soulseek: <a
href="/archives/2006/soulski/soulseek-library-0.01.zip">soulseek-library-0.01.zip</a>
I started writing a GUI library in C for it: <a
href="/archives/2006/soulski/exgui-library-0.1.zip">exgui-library-0.1.zip</a>
I started writing a CSS parser in C for it: <a
href="/archives/2006/soulski/css-library-prototype-0.01.zip">css-library-prototype-0.01.zip</a></p>
<p>I originally had big ambitions for this, but later lost interest. It
looks like I planned to rewrite it in Common Lisp, but got bored of the
project before I did.</p>
<h2 id="wdn">wdn</h2>
<p>I had a project called ‘windows desktop notes’ (WDN), that I
originally <a href="/archives/2006/wdm/slsk-code-r110-wdm.zip">wrote in
C</a>. It would overlay some plain text notes on your desktop and you
could click it and get an edit box and then hit Enter to save again.</p>
<p>Then I ported it, or tried to, <a
href="/archives/2006/wdn/wdn.lisp">to Lisp</a>.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Ezra Cooper, Samuel Lindley, Philip Wadler and Jeremy
Yallop “An idiom’s guide to formlets” Technical Report,
EDI-INF-RR-1263.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Michael had previously built a tool called fpbuild which
basically was kind of like a big lock file and was unreasonably
effective at building very large Yesod-based projects.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>It just had a small technological advantage of being
based on GHC’s parser, rather than haskell-src-exts, which is always
playing catch-up.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Which I consider a bit of a setback towards the dream of
making style choices a thing of the past. But I think Ormolu will win
eventually. Maintaining forks is hard work.<a href="#fnref4"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>componentm-devel, espial, essence-of-live-coding,
essence-of-live-coding-gloss, essence-of-live-coding-pulse,
ghci-websockets, halive, jsaddle-warp, monomer, nvim-hs, rapid<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>In retrospect I mishandled a situation where Fay was
being used in production and we were breaking its APIs too often, and I
blocked Adam’s <code>master</code> push access to the repo to give me
some breathing room to slow things down, but this was obviously the
wrong move, and not how you should treat early collaborators. That was
my first experience managing a project, so I cut my younger self some
slack. However, he was very gracious about it in the moment.<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>See a complete history <a
href="https://chrisdone.com/posts/clientside-programming-haskell/">here.</a><a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<footer>
  <table style="width:100%">
    <tr>
      <td>© 2024-05-12 <a href="/">Chris Done</a></td>
      <td style="text-align:right"><a href="/posts">Read more posts →</a></td>
    </tr>
  </table>
</footer>

    </div>
  </body>
</html>
