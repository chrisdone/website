<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>shell-conduit: Write shell scripts in Haskell with Conduit</title>
  <style>body {
  max-width: 40em;
  margin: .5in auto;
  font-size: 18px;
  font-family: serif;
  margin-top: 5em;
  line-height: 1.5;
}
pre, code {
  font-size: 16px;
}
pre {
  margin-left: 1.5em;
  line-height: 1.2;
}
a {
  color: #1a6e8e
}
.menu a {
  margin-right: 1em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Helvetica;
}

h1 a,h2 a,h3 a,h4 a {
  text-decoration: none;
  color: inherit;
}

.post-1,.post-2{
  margin-bottom: 0.5em;
}

.author {
  display: none;
}

footer {
  margin-top: 1.5em;
  padding-top: 1.5em;
  border-top: 1px solid #ccc;
  margin-bottom: 2em
}

footer span {
  display: none;
}

img {
  max-width: 100%
}
pre.sourceCode span.st {
  color: #366354
}
pre.sourceCode span.kw {
  color: #397460
}
pre.sourceCode span.fu {
  color: #8f4e8b
}
pre.sourceCode span.ot {
  color: #2e659c
}
pre.sourceCode span.dt {
  color: #4F4371
}
pre.sourceCode span.co {
  color: #666
}
  </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>shell-conduit: Write shell scripts in Haskell with Conduit</h1>
<p class="author">By <a href="https://chrisdone.com/">Chris Done</a></p>

<p>As part of my series of write-about-personal-projects, my latest obsession is writing shell scripts with Michael Snoyman’s <a href="https://hackage.haskell.org/package/conduit">Conduit</a>.</p>
<p>Here is my package, <a href="https://github.com/chrisdone/shell-conduit/">shell-conduit</a>. It’s still in the experimental phase, but I don’t forsee any changes now for a while.</p>
<h2 id="bash-is-evil">Bash is evil</h2>
<p>I hate writing scripts in Bash. Until now, it was the easiest way to just write unix scripts. Its syntax is insane, incredibly error prone, its defaults are awful, and it’s not a real big person programming language.</p>
<h2 id="perlpythonruby-are-also-evil">Perl/Python/Ruby are also evil</h2>
<p>If you’re going to go as far as using a real programming language, why bother with these dynamically typed messes? Go straight for Haskell.</p>
<h2 id="like-a-glove">Like a glove</h2>
<div class="figure">
<img src="https://24.media.tumblr.com/tumblr_m3037pY5x71qbkdr4o1_500.gif" ><p class="caption"></p>
</div>
<p>I had an inkling a while back that conduits mirror the behaviour of bash pipes very well. I knew there was something to the idea, but didn’t act on it fully for a while. Last week I experimented somewhat and realised that the following Haskell code</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">source <span class="fu">$=</span> conduit <span class="fu">$</span> sink</code></pre>
<p>does indeed accurately mirror</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">source</span> <span class="kw">|</span> <span class="kw">conduit</span> <span class="kw">&gt;</span> sink</code></pre>
<p>And that also the following</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="kw">do</span> source
    source <span class="fu">$=</span> conduit)
<span class="fu">$$</span> sink</code></pre>
<p>is analogous to</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">source</span>
<span class="kw">source</span> <span class="kw">|</span> <span class="kw">conduit</span></code></pre>
<p>We’ll see examples of why this works later.</p>
<h2 id="i-must-haskell-all-the-things">I must Haskell all the things</h2>
<p>Another trick I realised is to write some template Haskell code which will calculate all executables in your PATH at compilation time and generate a top-level name that is a Haskell function to launch that process. So instead of writing</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">run <span class="st">&quot;ls&quot;</span></code></pre>
<p>you could instead just write</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">ls</code></pre>
<p>There are a few thousand executables, so it takes about 10 seconds to compile such a module of names. But that’s all.</p>
<p>Again, we’ll see how awesome this looks in a minute.</p>
<h2 id="modeling-stdin-stderr-and-stdout">Modeling stdin, stderr and stdout</h2>
<p>My choice of modeling the typical shell scripting pipe handles is by having a type called <code>Chunk</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Chunk</span> <span class="fu">=</span> <span class="dt">Either</span> <span class="dt">ByteString</span> <span class="dt">ByteString</span></code></pre>
<p>All <code>Left</code> values are from <code>stderr</code>. All <code>Right</code> values are either being pulled from <code>stdin</code> or being sent to <code>stdout</code>. In a conduit the difference between <code>stdin</code> and <code>stdout</code> is more conceptual than real.</p>
<p>When piping two commands, the idea is that any <code>Left</code> values are just re-yielded along, they are not consumed and passed into the process.</p>
<h2 id="a-process-conduit-on-chunks">A process conduit on chunks</h2>
<p>Putting the previous model into practice, we come up with a type for launching a process like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">conduitProcess ::</span> (<span class="dt">MonadResource</span> m)
               <span class="ot">=&gt;</span> <span class="dt">CreateProcess</span> <span class="ot">-&gt;</span> <span class="dt">Conduit</span> <span class="dt">Chunk</span> m <span class="dt">Chunk</span></code></pre>
<p>Meaning the process will be launched, and the conduit will accept any upstream <code>stdin</code> (<code>Right</code> values), and send downstream anything that comes from the actual process (both <code>Left</code> and <code>Right</code> values).</p>
<h2 id="process-conduits-api">Process conduits API</h2>
<p>I defined two handy functions for running process conduits:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shell ::</span> (<span class="dt">MonadResource</span> m)
      <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Conduit</span> <span class="dt">Chunk</span> m <span class="dt">Chunk</span>
<span class="ot">proc ::</span> (<span class="dt">MonadResource</span> m)
     <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Conduit</span> <span class="dt">Chunk</span> m <span class="dt">Chunk</span></code></pre>
<p>One to launch via a shell, one to launch via program name and arguments. These functions can be used in your shell scripts. Though, we’ll see in a minute why you should rarely need either.</p>
<h2 id="executing-a-shell-scripting-conduit">Executing a shell scripting conduit</h2>
<p>First we want something to consume any remainder chunks after a script has finished. That’s <code>writeChunks</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">writeChunks ::</span> (<span class="dt">MonadIO</span> m)
            <span class="ot">=&gt;</span> <span class="dt">Consumer</span> <span class="dt">Chunk</span> m ()
writeChunks <span class="fu">=</span>
  awaitForever
    (\c <span class="ot">-&gt;</span>
       <span class="kw">case</span> c <span class="kw">of</span>
         <span class="dt">Left</span> e <span class="ot">-&gt;</span> liftIO (S.hPut stderr e)
         <span class="dt">Right</span> o <span class="ot">-&gt;</span> liftIO (S.hPut stdout o))</code></pre>
<p>This simply consumes anything left in the pipeline and outputs to the correct file handles, either <code>stderr</code> or <code>stdout</code>.</p>
<p>Now we can write a simple <code>run</code> function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> (<span class="dt">MonadIO</span> m,<span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m)
    <span class="ot">=&gt;</span> <span class="dt">Conduit</span> <span class="dt">Chunk</span> (<span class="dt">ShellT</span> m) <span class="dt">Chunk</span> <span class="ot">-&gt;</span> m ()
run p <span class="fu">=</span>
  runResourceT
    (runShellT (sourceList [] <span class="fu">$=</span>
                p <span class="fu">$</span>
                writeChunks))</code></pre>
<p>First it yields an empty upstream of chunks. That’s the source. Then our script <code>p</code> is run as the conduit in between, finally we write out any chunks that remain.</p>
<p>Let’s try that out:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; run (shell <span class="st">&quot;echo hello!&quot;</span>)
hello<span class="fu">!</span>
λ&gt; run (proc <span class="st">&quot;date&quot;</span> [<span class="st">&quot;+%Y&quot;</span>])
<span class="dv">2014</span>
λ&gt; run (shell <span class="st">&quot;echo oops &gt; /dev/stderr&quot;</span>)
oops</code></pre>
<p>Looks good. Standard output was written properly, as was stderr.</p>
<h2 id="returning-to-our-mass-name-generation">Returning to our mass name generation</h2>
<p>Let’s take our earlier work of generating names with template-haskell. With that in place, we have a process conduit for every executable in <code>PATH</code>. Add to that variadic argument handling for each one, we get a list of names like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rmdir ::</span> <span class="dt">ProcessType</span> r <span class="ot">=&gt;</span> r
<span class="ot">ls ::</span> <span class="dt">ProcessType</span> r <span class="ot">=&gt;</span> r
<span class="ot">egrep ::</span> <span class="dt">ProcessType</span> r <span class="ot">=&gt;</span> r
<span class="ot">dmesg ::</span> <span class="dt">ProcessType</span> r <span class="ot">=&gt;</span> r</code></pre>
<p>The real types when instantiated will look like:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rmdir <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Conduit</span> <span class="dt">Chunk</span> m <span class="dt">Chunk</span>
<span class="ot">ls ::</span> <span class="dt">Conduit</span> <span class="dt">Chunk</span> m <span class="dt">Chunk</span>
ls <span class="st">&quot;.&quot;</span><span class="ot"> ::</span> <span class="dt">Conduit</span> <span class="dt">Chunk</span> m <span class="dt">Chunk</span></code></pre>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>We can now provide any number of arguments:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; run ls
dist
<span class="dt">LICENSE</span>
README.md
Setup.hs
shell<span class="fu">-</span>conduit<span class="fu">.</span>cabal
src
<span class="dt">TAGS</span>
TODO.org
λ&gt; run (ls <span class="st">&quot;/&quot;</span>)
bin
boot
cdrom
…</code></pre>
<p>We can pipe things together:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; run (<span class="kw">do</span> ls <span class="st">&quot;-1&quot;</span> <span class="fu">$=</span> head' <span class="st">&quot;-2&quot;</span>)
dist
<span class="dt">LICENSE</span>
λ&gt; run (ls <span class="fu">$=</span> grep <span class="st">&quot;Key&quot;</span> <span class="fu">$=</span> shell <span class="st">&quot;cat&quot;</span> <span class="fu">$=</span> CL.map (second (S8.map toUpper)))
<span class="dt">KEYBOARD.HI</span>
<span class="dt">KEYBOARD.HS</span>
<span class="dt">KEYBOARD.O</span></code></pre>
<p>Results are outputted to stdout unless piped into other processes:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; run (<span class="kw">do</span> shell <span class="st">&quot;echo sup&quot;</span>; shell <span class="st">&quot;echo hi&quot;</span>)
sup
hi
λ&gt; run (<span class="kw">do</span> shell <span class="st">&quot;echo sup&quot;</span>; sed <span class="st">&quot;s/u/a/&quot;</span>; shell <span class="st">&quot;echo hi&quot;</span>)
sup
hi
λ&gt; run (<span class="kw">do</span> shell <span class="st">&quot;echo sup&quot;</span> <span class="fu">$=</span> sed <span class="st">&quot;s/u/a/&quot;</span>; shell <span class="st">&quot;echo hi&quot;</span>)
sap
hi</code></pre>
<p>Live streaming between pipes like in normal shell scripting is possible:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; run (<span class="kw">do</span> tail' <span class="st">&quot;/tmp/example.txt&quot;</span> <span class="st">&quot;-f&quot;</span> <span class="fu">$=</span> grep <span class="st">&quot;--line-buffered&quot;</span> <span class="st">&quot;Hello&quot;</span>)
<span class="dt">Hello</span>, world<span class="fu">!</span>
<span class="dt">Oh</span>, hello<span class="fu">!</span></code></pre>
<p>(Remember that <code>grep</code> needs <code>--line-buffered</code> if it is to output things line-by-line).</p>
<h2 id="error-handling">Error handling</h2>
<p>By default, if a process errors out, the whole script ends. This is contrary to Bash, which keeps going regardless of failure. This is bad.</p>
<p>In Bash, to revert this default, you run:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">set</span> <span class="kw">-e</span></code></pre>
<p>And the way to ignore erroneous commands on case-by-case basis is to use <code>|| true</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">killall nonexistant <span class="fu">||</span> true
echo <span class="dt">OK</span>, done<span class="fu">.</span></code></pre>
<p>Which means “do foo, or otherwise ignore it, continue the script”.</p>
<p>We can express the same thing using the Alternative instance for the <code>ShellT</code> type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; run (<span class="kw">do</span> killall <span class="st">&quot;nonexistant&quot;</span> <span class="st">&quot;-q&quot;</span>; echo <span class="st">&quot;OK, done.&quot;</span>)
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">ShellExitFailure</span> <span class="dv">1</span>
λ&gt; run (<span class="kw">do</span> killall <span class="st">&quot;nonexistant&quot;</span> <span class="st">&quot;-q&quot;</span> <span class="fu">&lt;|&gt;</span> return (); echo <span class="st">&quot;OK, done.&quot;</span>)
<span class="dt">OK</span>, done<span class="fu">.</span></code></pre>
<h2 id="string-types">String types</h2>
<p>If using <code>OverloadedStrings</code> so that you can use <code>Text</code> for arguments, then also enable <code>ExtendedDefaultRules</code>, otherwise you’ll get ambiguous type errors.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExtendedDefaultRules #-}</span></code></pre>
<p>But this isn’t necessary if you don’t need to use <code>Text</code> yet. Strings literals will be interpreted as <code>String</code>. Though you can pass a value of type <code>Text</code> or any instance of <code>CmdArg</code> without needing conversions.</p>
<h2 id="examples-of-script-files">Examples of script files</h2>
<p>Quick script to reset my keyboard (Linux tends to forget these things when I unplug my keyboard):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Data.Conduit.Shell
main <span class="fu">=</span>
  run (<span class="kw">do</span> xmodmap <span class="st">&quot;.xmodmap&quot;</span>
          xset <span class="st">&quot;r&quot;</span> <span class="st">&quot;rate&quot;</span> <span class="st">&quot;150&quot;</span> <span class="st">&quot;50&quot;</span>)</code></pre>
<p>Cloning and initializing a repo (ported from a bash script):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Control.Monad.IO.Class
<span class="kw">import</span> Data.Conduit.Shell
<span class="kw">import</span> System.Directory
main <span class="fu">=</span>
  run (<span class="kw">do</span> exists <span class="ot">&lt;-</span> liftIO (doesDirectoryExist <span class="st">&quot;fpco&quot;</span>)
          <span class="kw">if</span> exists
             <span class="kw">then</span> rm <span class="st">&quot;fpco/.hsenvs&quot;</span> <span class="st">&quot;-rf&quot;</span>
             <span class="kw">else</span> git <span class="st">&quot;clone&quot;</span> <span class="st">&quot;git@github.com:fpco/fpco.git&quot;</span>
          liftIO (setCurrentDirectory <span class="st">&quot;fpco&quot;</span>)
          shell <span class="st">&quot;./dev-scripts/update-repo.sh&quot;</span>
          shell <span class="st">&quot;./dev-scripts/build-all.sh&quot;</span>
          alertDone)</code></pre>
<p>Script to restart a web process (ported from an old bash script I had):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> Control.Applicative
<span class="kw">import</span> Control.Monad.Fix
<span class="kw">import</span> Data.Conduit.Shell
main <span class="fu">=</span>
  run (<span class="kw">do</span> ls
          echo <span class="st">&quot;Restarting server ... ?&quot;</span>
          killall name <span class="st">&quot;-q&quot;</span> <span class="fu">&lt;|&gt;</span> return ()
          fix (\loop <span class="ot">-&gt;</span>
                 <span class="kw">do</span> echo <span class="st">&quot;Waiting for it to terminate ...&quot;</span>
                    sleep <span class="st">&quot;1&quot;</span>
                    (ps <span class="st">&quot;-C&quot;</span> name <span class="fu">$=</span> discardChunks <span class="fu">&gt;&gt;</span> loop) <span class="fu">&lt;|&gt;</span> return ())
          shell <span class="st">&quot;dist/build/ircbrowse/ircbrowse ircbrowse.conf&quot;</span>)
  <span class="kw">where</span> name <span class="fu">=</span> <span class="st">&quot;ircbrowse&quot;</span></code></pre>
<h2 id="youve-seen-shelly-right">You’ve seen Shelly, right?</h2>
<p>Right. Shelly’s fine. It just lacks the two killer things for me:</p>
<ul>
<li>All names are bound, so I can just use them as normal functions.</li>
<li>shell-conduit also, due to its mass name binding, prioritizes commands. For example, Shelly has <a href="https://hackage.haskell.org/package/shelly-1.5.5/docs/Shelly.html#g:9">a group of functions for manipulating the file system</a>. In shell-conduit, you just use your normal commands: <code>rm &quot;x&quot;</code> and <code>mv   &quot;x&quot; &quot;y&quot;</code>.</li>
<li>Not based on conduit. Conduit is a whole suite of streaming utilities perfect for scripting.</li>
<li>Piped is not the default, either. There’re a bunch of choices: Shelly, Shelly.Lifted, Shelly.Pipe. Choice is good, but for a scripting language I personally prefer one goto way to do something.</li>
</ul>
<p>Also, Shelly cannot do live streams like Conduit can.</p>
<h2 id="conduits-as-good-scripting-libraries">Conduits as good scripting libraries</h2>
<p>You might want to import the regular Conduit modules qualified, too:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="kw">qualified</span> Data.Conduit.List <span class="kw">as</span> CL</code></pre>
<p>Which contains handy functions for working on streams in a list-like way. See the rest of the handy modules for Conduit in <a href="https://hackage.haskell.org/package/conduit-extra">conduit-extra</a>.</p>
<p>Also of interest is <a href="https://hackage.haskell.org/package/csv-conduit">csv-conduit</a>, <a href="http://hackage.haskell.org/package/html-conduit">html-conduit</a>, and <a href="http://hackage.haskell.org/package/http-conduit">http-conduit</a>.</p>
<p>Finally, see the Conduit category on Hackage for other useful libraries: <a href="https://hackage.haskell.org/packages/#cat:Conduit"><code class="url">http://hackage.haskell.org/packages/#cat:Conduit</code></a></p>
<p>All of these general purpose Conduits can be used in shell scripting.</p>
<h2 id="using-it-for-real-scripts">Using it for real scripts</h2>
<p>So far I have ported a few small scripts to shell-conduit from Bash and have been happy every time. I suck at Bash. I’m pretty good at Haskell.</p>
<p>The next test is applying this to my Hell shell and seeing if I can use it as a commandline shell, too.</p>
<p>My friend complained that having to quote all arguments is a pain. I don’t really agree that this is bad. In Bash it’s often unclear how arguments are going to be interpreted. I’m happy just writing something predictable than something super convenient but possibly nonsense.</p>
<h2 id="summary">Summary</h2>
<p>I set out a week ago to just stop writing Bash scripts. I’ve written a bunch of scripts in Haskell, but I would still write Bash scripts too. Some things were just too boring to write. I wanted to commit to Haskell for scripting. Today, I’m fairly confident I have a solution that is going to be satisfactory for a long while.</p>

<footer>
  © 2014-09-21 Chris Done &lt;chrisdone@gmail.com&gt;
<span style="float:right"><a href="../rss.xml">RSS</a></span>
</footer>

    </div>

  </body>
</html>
