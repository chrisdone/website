<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Typeable and Data in Haskell</title>
    <style>
      body {
      max-width: 40em;
      margin: .5in auto;
      font-size: 18px;
      font-family: serif;
      line-height: 1.5;
      }
      pre, code {
      font-size: 16px;
      word-wrap: break-word;
      }
      pre {
      margin-left: 1.5em;
      line-height: 1.5em;
      }
      a {
      color: #1a6e8e
      }
      .menu a {
      margin-right: 1em;
      }
      h1,h2,h3,h4,h5,h6 {
      font-family: Helvetica;
      }

      h1 a,h2 a,h3 a,h4 a {
      text-decoration: none;
      color: inherit;
      }

      .post-1,.post-2{
      margin-bottom: 0.5em;
      }

      .author {
      display: none;
      }

      footer {
      margin-top: 1.5em;
      padding-top: 1.5em;
      border-top: 1px solid #ccc;
      margin-bottom: 2em
      }

      footer span {
      display: none;
      }

      img {
      max-width: 100%
      }
      pre.sourceCode span.st {
      color: #366354
      }
      pre.sourceCode span.kw {
      color: #397460
      }
      pre.sourceCode span.fu {
      color: #8f4e8b
      }
      pre.sourceCode span.ot {
      color: #2e659c
      }
      pre.sourceCode span.dt {
      color: #4F4371
      }
      pre.sourceCode span.co {
      color: #666
      }
      @media(max-width:767px){
      body { margin: 1px 4px; }
      h1, h2, .menu { margin: 0; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.125em; }
      h3 { font-size: 1.0125em; }
      .menu a { margin-right: 0.1em; }
      #archive { margin-left: 1em; margin-top: 0; padding: 0}
      #archive .post-1, #archive .post-2 {
      margin-bottom: 0.1em;
      }
      }
      .footnote-ref { text-decoration: none; }
    </style>
  </head>
  <body>
    <div class="page-wrap">

<h1>Typeable and Data in Haskell</h1>

<p><a
href="hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable.html">Data.Typeable</a>
and <a
href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Data.html">Data.Data</a>
are rather mysterious. Starting out as a Haskell newbie you see them
once in a while and wonder what use they are. Their Haddock pages are
pretty opaque and scary in places. Here’s a quick rundown I thought I’d
write to get people up to speed nice and quick so that they can start
using it.<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p>It’s really rather beautiful as a way to do generic programming in
Haskell. The general approach is that you don’t know what data types are
being given to you, but you want to work upon them almost as if you did.
The technique is simple when broken down.</p>
<h2 id="requirements">Requirements</h2>
<p>First, there is a class exported by each module. The class
<code>Typeable</code> and the class <code>Data</code>. Your data types
have to be instances of these if you want to use the generic programming
methods on them.</p>
<p>Happily, we don’t have to write these instances ourselves (and in GHC
7.8 it is actually not possible to do so): GHC provides the extension
<code>DeriveDataTypeable</code>, which you can enable by adding
<code>{-# LANGUAGE DeriveDataTypeable #-}</code> to the top of your
file, or providing <code>-XDeriveDataTypeable</code> to
<code>ghc</code>.</p>
<p>Now you can derive instances of both:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">X</span> <span class="ot">=</span> <span class="dt">X</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Data</span>,<span class="dt">Typeable</span>)</span></code></pre></div>
<p>Now we can start doing generic operations upon <code>X</code>.</p>
<h2 id="the-typeable-class">The Typeable class</h2>
<p>As a simple starter, we can trivially print the type of any instance
of <code>Typeable</code>. What are some existing instances of
<code>Typeable</code>? Let’s ask GHCi:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>i <span class="dt">Typeable</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Typeable</span> a <span class="kw">where</span><span class="ot"> typeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] (<span class="dt">Typeable1</span> s, <span class="dt">Typeable</span> a) <span class="ot">=&gt;</span> <span class="dt">Typeable</span> (s a)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">TypeRep</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">TyCon</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">Ordering</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">Integer</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">Int</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">Float</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">Double</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">Char</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">Bool</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> ()</span></code></pre></div>
<p>That’s the basic Prelude types and the Typeable library’s own
types.</p>
<p>There’s only one method in the <code>Typeable</code> class:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></span></code></pre></div>
<p>The <code>TypeRep</code> value has some useful normal instances:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>i <span class="dt">TypeRep</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Eq</span> <span class="dt">TypeRep</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Ord</span> <span class="dt">TypeRep</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Show</span> <span class="dt">TypeRep</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> [overlap ok] <span class="dt">Typeable</span> <span class="dt">TypeRep</span></span></code></pre></div>
<h2 id="use-case-1-print-the-type-of-something">Use-case 1: Print the
type of something</h2>
<p>So we can use this function on a <code>Char</code> value, for
example, and GHCi can print it:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t typeOf <span class="ch">&#39;a&#39;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>typeOf <span class="ch">&#39;a&#39;</span><span class="ot"> ::</span> <span class="dt">TypeRep</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> typeOf <span class="ch">&#39;a&#39;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Char</span></span></code></pre></div>
<p>This is mostly useful for debugging, but can also be useful when
writing generic encoders or any tool which needs an identifier to be
associated with some generic value.</p>
<h2 id="use-case-2-compare-the-types-of-two-things">Use-case 2: Compare
the types of two things</h2>
<p>We can also compare two type representations:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> typeOf <span class="ch">&#39;a&#39;</span> <span class="op">==</span> typeOf <span class="ch">&#39;b&#39;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> typeOf <span class="ch">&#39;a&#39;</span> <span class="op">==</span> typeOf ()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span></span></code></pre></div>
<p>Any code which needs to allow any old type to be passed into it, but
which has some interest in sometimes enforcing or triggering on a
specific type can use this to compare them.</p>
<h2 id="use-case-3-reifying-from-generic-to-concrete">Use-case 3:
Reifying from generic to concrete</h2>
<p>A common thing to need to do is when given a generic value, is to
sometimes, if the type is right, actually work with the value as the
concrete type, not a polymorphic type. For example, a printing
function:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">char ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>The specification for this function is: if given an
<code>Char</code>, return its string representation, otherwise, return
<code>"unknown"</code>. To do this, we need a function that will convert
from a polymorphic value to a concrete one:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cast ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span></code></pre></div>
<p>This function from <code>Data.Typeable</code> will do just that. Now
we can implement <code>char</code>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> char x <span class="ot">=</span> <span class="kw">case</span> cast x <span class="kw">of</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Just</span> (<span class="ot">x ::</span> <span class="dt">Char</span>) <span class="ot">-&gt;</span> <span class="fu">show</span> x</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;unknown&quot;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> char <span class="ch">&#39;a&#39;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&#39;a&#39;&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> char <span class="dv">5</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;unknown&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> char ()</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;unknown&quot;</span></span></code></pre></div>
<h2 id="the-data-class">The Data class</h2>
<p>That’s more or less where the interesting practical applications of
the <code>Typeable</code> class ends. But it becomes more interesting
once you have that, the <code>Data</code> class can take advantage of
it. The <code>Data</code> class is much more interesting. The point is
to be able to look into a data type’s constructors, its fields and
traverse across or fold over them. Let’s take a look at the class.</p>
<p>Again, there are some basic instances provided:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> [a]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Ordering</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> (<span class="dt">Maybe</span> a)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Integer</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Int</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Float</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Data</span> a, <span class="dt">Data</span> b) <span class="ot">=&gt;</span> <span class="dt">Data</span> (<span class="dt">Either</span> a b)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Double</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Char</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Bool</span></span></code></pre></div>
<p>It’s a rather big class, so I’ll just cover some methods that
demonstrate the key use-cases.</p>
<h2 id="use-case-1-get-the-data-type">Use-case 1: Get the data type</h2>
<p>Similar to the <code>TypeRep</code>, you can use
<code>dataTypeOf</code> to get a unique representation of a data
type:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dataTypeOf ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DataType</span></span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> dataTypeOf (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">DataType</span> {tycon <span class="ot">=</span> <span class="st">&quot;Prelude.Maybe&quot;</span>, datarep <span class="ot">=</span> <span class="dt">AlgRep</span> [<span class="dt">Nothing</span>,<span class="dt">Just</span>]}</span></code></pre></div>
<p>There aren’t any other interesting instances for this type, but we’ll
look at uses for this type later. Representations (so-called
<code>FooRep</code>) tend to be references from which you can reify into
more concrete values.</p>
<h2 id="use-case-2-inspecting-a-data-type">Use-case 2: Inspecting a data
type</h2>
<p>The most common thing to want to do is to get a list of constructors
that a type contains. So, the <code>Maybe</code> type contains two.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t dataTypeConstrs</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">dataTypeConstrs ::</span> <span class="dt">DataType</span> <span class="ot">-&gt;</span> [<span class="dt">Constr</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> dataTypeConstrs (dataTypeOf (<span class="dt">Nothing</span><span class="ot"> ::</span> <span class="dt">Maybe</span> ()))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Nothing</span>,<span class="dt">Just</span>]</span></code></pre></div>
<p>We’ll look at what we can do with constructors later.</p>
<p>It’s also surprisingly common to want to see what the constructor is
at a particular index. We could write this function ourself, but there’s
already one provided:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> indexConstr (dataTypeOf (<span class="dt">Nothing</span><span class="ot"> ::</span> <span class="dt">Maybe</span> ())) <span class="dv">2</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span></span></code></pre></div>
<p>Sometimes you want to know whether a data type is algebraic (in other
words, does it have constructors and is it not one of the built-in types
like Int/Float/etc)?</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> isAlgType (dataTypeOf (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> isAlgType (dataTypeOf <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span></span></code></pre></div>
<p><img src="http://i.imgur.com/RfXKwQ3.gif" /></p>
<h2 id="use-case-3-get-the-constructor-of-a-value">Use-case 3: Get the
constructor of a value</h2>
<p>We have the method</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toConstr ::</span> a <span class="ot">-&gt;</span> <span class="dt">Constr</span></span></code></pre></div>
<p>Which given any instance of <code>Data</code> will yield a
constructor.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>i <span class="dt">Constr</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Constr</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Constr</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Constr</span></span></code></pre></div>
<p>You can’t do much with a constructor as-is, but compare and print
it:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> toConstr (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> toConstr (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>) <span class="op">==</span> toConstr (<span class="dt">Nothing</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Char</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span></span></code></pre></div>
<p>However, those operations by themselves can be useful.</p>
<p>By the way, we can also get back the <code>DataRep</code> of a
constructor:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> constrType (toConstr (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="dt">DataType</span> {tycon <span class="ot">=</span> <span class="st">&quot;Prelude.Maybe&quot;</span>, datarep <span class="ot">=</span> <span class="dt">AlgRep</span> [<span class="dt">Nothing</span>,<span class="dt">Just</span>]}</span></code></pre></div>
<h2 id="use-case-4-get-fields-of-a-constructor">Use-case 4: Get fields
of a constructor</h2>
<p>Another typical thing to want to do is to use the field names of a
constructor. So for example:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">X</span> <span class="ot">=</span> <span class="dt">X</span> {<span class="ot"> foo ::</span> <span class="dt">Int</span>,<span class="ot"> bar ::</span> <span class="dt">Char</span> } <span class="kw">deriving</span> (<span class="dt">Typeable</span>,<span class="dt">Data</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> toConstr (<span class="dt">X</span> <span class="dv">0</span> <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">X</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> constrFields (toConstr (<span class="dt">X</span> <span class="dv">0</span> <span class="ch">&#39;a&#39;</span>))</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>]</span></code></pre></div>
<p>It’s a good use-case for serializing and debugging.</p>
<h2 id="use-case-5-make-a-real-value-from-its-constructor">Use-case 5:
Make a real value from its constructor</h2>
<p>It’s actually possible to produce a value from its constructor. We
have this function</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromConstr ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">Constr</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> fromConstr (toConstr (<span class="dt">Nothing</span><span class="ot"> ::</span> <span class="dt">Maybe</span> ()))<span class="ot"> ::</span> <span class="dt">Maybe</span> ()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span></span></code></pre></div>
<p>But what do you do when the constructor has fields? No sweat. We have
this function:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromConstrB ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Data</span> a</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> (<span class="kw">forall</span> d<span class="op">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> d) <span class="ot">-&gt;</span> <span class="dt">Constr</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p><img src="http://i.imgur.com/vs9AG.gif" /></p>
<p>Haskell beginners: Don’t fear the rank-N type. What it’s saying is
merely that the <code>fromConstrB</code> function determines what the
type of <code>d</code> will be by itself, by looking at
<code>Constr</code>. It’s not provided externally by the caller, as it
would be if the <code>forall d.</code> were at the same level as the
<code>a</code>. Think of it like scope.
<code>let a = d in let d = …</code> doesn’t make sense: the
<code>d</code> is in a lower scope. That means we can’t just write:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>fromConstrB (<span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>) (toConstr (<span class="dt">Just</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>))<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span></code></pre></div>
<p>The <code>Int</code> cannot unify with the <code>d</code> because the
quantification is one level lower. It basically doesn’t exist outside of
the <code>(forall d. Data d =&gt; d)</code> (nor can it escape). That’s
okay, though. There is a type-class constraint which lets us be generic.
We already have a function producing a value of that type:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t fromConstr (toConstr (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>))</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>fromConstr (toConstr (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>))<span class="ot"> ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a</span></code></pre></div>
<p>So we can just use that:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> fromConstrB (fromConstr (toConstr (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>               (toConstr (<span class="dt">Just</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>))<span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">1</span></span></code></pre></div>
<p>Tada! But wait… What if there’re <em>more</em> fields? How do we
provide more than one, and of different types?</p>
<p>Enter <code>fromConstrM</code>:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromConstrM ::</span> <span class="kw">forall</span> m a<span class="op">.</span> (<span class="dt">Monad</span> m, <span class="dt">Data</span> a)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> (<span class="kw">forall</span> d<span class="op">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> m d) <span class="ot">-&gt;</span> <span class="dt">Constr</span> <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>Because it’s monadic we can use a state monad to keep an index!
Observe:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t execState</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ot">execState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t execState (modify (<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>execState (modify (<span class="op">+</span><span class="dv">1</span>))<span class="ot"> ::</span> <span class="dt">Num</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t execState (forM_ [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] (<span class="fu">const</span> (modify (<span class="op">+</span><span class="dv">1</span>))))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>execState (forM_ [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] (<span class="fu">const</span> (modify (<span class="op">+</span><span class="dv">1</span>))))<span class="ot"> ::</span> <span class="dt">Num</span> s <span class="ot">=&gt;</span> s<span class="ot">-&gt;</span> s</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> execState (forM_ [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>] (<span class="fu">const</span> (modify (<span class="op">+</span><span class="dv">1</span>)))) <span class="dv">5</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code></pre></div>
<p>Let’s put this to use with <code>fromConstrM</code>:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> evalState</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>     (fromConstrM</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>       (<span class="kw">do</span> i <span class="ot">&lt;-</span> get</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>           modify (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>           <span class="fu">return</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>             (<span class="kw">case</span> i <span class="kw">of</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>               <span class="dv">0</span> <span class="ot">-&gt;</span> fromConstr (toConstr (<span class="dv">5</span><span class="ot">::</span><span class="dt">Int</span>))</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>               <span class="dv">1</span> <span class="ot">-&gt;</span> fromConstr (toConstr <span class="ch">&#39;b&#39;</span>)))</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>       (toConstr (<span class="dt">Foo</span> <span class="dv">4</span> <span class="ch">&#39;a&#39;</span>)))</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>     <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Foo</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Foo</span> <span class="dv">5</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span></span></code></pre></div>
<p>In other words, keep an index starting at 0. Increase it each
iteration that <code>fromConstrM</code> does. When we’re at index 0,
return an <code>Int</code>, when we’re at index 1, return a
<code>Char</code>. Easy! Right?</p>
<p><img src="http://i.imgur.com/HfAq4.gif" /></p>
<h2 id="use-case-6-mapping-over-data-structures-generically">Use-case 6:
mapping over data structures generically</h2>
<p>A common thing to want is to map over a value in a
structure-preserving way, but changing its values. For that we have
<code>gmapT</code>:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">gmapT ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Data</span> a</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> (<span class="kw">forall</span> b<span class="op">.</span> <span class="dt">Data</span> b <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Similar to <code>fromConstr*</code>, there is a rank-n type
<code>b</code> that refers to each type in the constructor of type
<code>a</code>. It’s easy enough to use:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> gmapT</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>     (\d <span class="ot">-&gt;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> cast d <span class="kw">of</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> d</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> x <span class="ot">-&gt;</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>            fromJust (cast (<span class="kw">if</span> <span class="fu">isUpper</span> x <span class="kw">then</span> <span class="ch">&#39;!&#39;</span> <span class="kw">else</span> x)))</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>     (<span class="dt">Foo</span> <span class="dv">4</span> <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Foo</span> <span class="dv">4</span> <span class="ch">&#39;a&#39;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> gmapT</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>     (\d <span class="ot">-&gt;</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> cast d <span class="kw">of</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> d</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Just</span> x <span class="ot">-&gt;</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>            fromJust (cast (<span class="kw">if</span> <span class="fu">isUpper</span> x <span class="kw">then</span> <span class="ch">&#39;!&#39;</span> <span class="kw">else</span> x)))</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>     (<span class="dt">Foo</span> <span class="dv">4</span> <span class="ch">&#39;A&#39;</span>)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="dt">Foo</span> <span class="dv">4</span> <span class="ch">&#39;!&#39;</span></span></code></pre></div>
<p>Here I’m doing a little check on any field in the constructor of type
<code>Char</code> and if it’s upper case, replacing it with
<code>!</code>, otherwise leaving it as-is. The first trick is to use
the <code>cast</code> function we used earlier to reify the generic
<code>d</code> into something real (<code>Char</code>). The second trick
is to cast our concrete <code>Char</code> back into a generic
<code>d</code> type.</p>
<p>Just like <code>fromConstrM</code> earlier, if you want to operate on
exact indices of the constructor rather than going by type, you can use
<code>gmapM</code> and use a state monad to do the same thing as we did
before.</p>
<h2 id="use-case-7-generating-from-data-structures-generically">Use-case
7: generating from data structures generically</h2>
<p>Another slightly different use-case is to walk over the values of a
data structure, collecting the result. You can do this with
<code>gmapM</code> and a state monad or a writer, but there’s a handy
function already to do this:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">gmapQ ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> (<span class="kw">forall</span> d<span class="op">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> d <span class="ot">-&gt;</span> u) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [u]</span></code></pre></div>
<p>Trivial example:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> gmapQ (\d <span class="ot">-&gt;</span> toConstr d) (<span class="dt">Foo</span> <span class="dv">5</span> <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="ch">&#39;a&#39;</span>]</span></code></pre></div>
<p>A more useful example can be found in <a
href="https://github.com/chrisdone/structured-haskell-mode/blob/18c011978acfca30bac800d0ac0e9e31e653c440/src/Main.hs#L96">structured-haskell-mode</a>
which walks over the Haskell syntax tree and collects source spans into
a flat list. Another decent example is in <a
href="https://github.com/chrisdone/present/blob/master/src/Present.hs#L75">the
present package</a>. There’s also an example in <a
href="https://github.com/faylang/fay/blob/master/src/Fay/Convert.hs#L54">Fay</a>
to encode types to JSON with a specific Fay-runtime-specific
encoding.</p>
<h2 id="printer-example">Printer example</h2>
<p>Here’s a trivial (not very good, but something I wrote once) generic
printer:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">gshows ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>gshows <span class="ot">=</span> render <span class="ot">`extQ`</span> (<span class="fu">shows</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ShowS</span>) <span class="kw">where</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  render t</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> isTuple <span class="ot">=</span> <span class="fu">showChar</span> <span class="ch">&#39;(&#39;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span> <span class="fu">drop</span> <span class="dv">1</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span> commaSlots</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span> <span class="fu">showChar</span> <span class="ch">&#39;)&#39;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> isNull <span class="ot">=</span> <span class="fu">showString</span> <span class="st">&quot;[]&quot;</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> isList <span class="ot">=</span> <span class="fu">showChar</span> <span class="ch">&#39;[&#39;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>             <span class="op">.</span> <span class="fu">drop</span> <span class="dv">1</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>             <span class="op">.</span> listSlots</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>             <span class="op">.</span> <span class="fu">showChar</span> <span class="ch">&#39;]&#39;</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">showChar</span> <span class="ch">&#39;(&#39;</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span> constructor</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span> slots</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span> <span class="fu">showChar</span> <span class="ch">&#39;)&#39;</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> constructor <span class="ot">=</span> <span class="fu">showString</span> <span class="op">.</span> showConstr <span class="op">.</span> toConstr <span class="op">$</span> t</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>          slots <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">.</span>) <span class="fu">id</span> <span class="op">.</span> gmapQ ((<span class="fu">showChar</span> <span class="ch">&#39; &#39;</span> <span class="op">.</span>) <span class="op">.</span> gshows) <span class="op">$</span> t</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>          commaSlots <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">.</span>) <span class="fu">id</span> <span class="op">.</span> gmapQ ((<span class="fu">showChar</span> <span class="ch">&#39;,&#39;</span> <span class="op">.</span>) <span class="op">.</span> gshows) <span class="op">$</span> t</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>          listSlots <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">.</span>) <span class="fu">id</span> <span class="op">.</span> <span class="fu">init</span> <span class="op">.</span> gmapQ ((<span class="fu">showChar</span> <span class="ch">&#39;,&#39;</span> <span class="op">.</span>) <span class="op">.</span> gshows) <span class="op">$</span> t</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>          isTuple <span class="ot">=</span> <span class="fu">all</span> (<span class="op">==</span><span class="ch">&#39;,&#39;</span>) (<span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">flip</span> <span class="fu">elem</span> <span class="st">&quot;()&quot;</span>) (constructor <span class="st">&quot;&quot;</span>))</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>          isNull <span class="ot">=</span> <span class="fu">null</span> (<span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">flip</span> <span class="fu">elem</span> <span class="st">&quot;[]&quot;</span>) (constructor <span class="st">&quot;&quot;</span>))</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>          isList <span class="ot">=</span> constructor <span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="st">&quot;(:)&quot;</span></span></code></pre></div>
<p>I wrote it because the GHC API doesn’t have <code>Show</code>
instances for most of its data types, so it’s rather hard to actually
inspect <em>any</em> data types that you’re working with in the REPL. It
has instances for pretty printing, but pretty printing confuses
presentation with data.</p>
<p>Example:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Foo</span> <span class="dt">Char</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Data</span>,<span class="dt">Typeable</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> gshow ([<span class="dt">Just</span> <span class="dv">2</span>],<span class="ch">&#39;c&#39;</span>,<span class="dt">Foo</span> <span class="ch">&#39;a&#39;</span> <span class="dv">5</span>)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;([(Just (2))],(&#39;c&#39;),(Foo (&#39;a&#39;) (5)))&quot;</span></span></code></pre></div>
<p>Note: no <code>Show</code> instance for <code>Foo</code>.</p>
<h2 id="summary">Summary</h2>
<p>We’ve briefly covered how to query types, how to cast them, how to
walk over them or generate from them. There’re other things one can do,
but those are the main things. The real trick is understanding how to
make the types work and that comes with a bit of experience. Fiddle
around with the concepts above and you should gain an intution for what
is possible with this library. See also: <a
href="http://hackage.haskell.org/package/syb-0.4.1/docs/Data-Generics-Aliases.html">Data.Generics.Aliases</a>.</p>
<p>Hope it helps!</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>I’ll migrate this to the HaskellWiki when it doesn’t
look so, uh, shall we say, unattractive.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


<footer>
  <table style="width:100%">
    <tr>
      <td>© 2014-04-22 <a href="/">Chris Done</a></td>
      <td style="text-align:right"><a href="/posts">Read more posts →</a></td>
    </tr>
  </table>
</footer>

    </div>
  </body>
</html>
