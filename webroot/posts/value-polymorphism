<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>“Value polymorphism”, simple explanation with examples</title>
  <style>body {
  max-width: 40em;
  margin: .5in auto;
  font-size: 18px;
  font-family: serif;
  margin-top: 5em;
  line-height: 1.5;
}
pre, code {
  font-size: 16px;
}
pre {
  margin-left: 1.5em;
  line-height: 1.2;
}
a {
  color: #1a6e8e
}
.menu a {
  margin-right: 1em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Helvetica;
}

h1 a,h2 a,h3 a,h4 a {
  text-decoration: none;
  color: inherit;
}

.post-1,.post-2{
  margin-bottom: 0.5em;
}

.author {
  display: none;
}

footer {
  margin-top: 1.5em;
  padding-top: 1.5em;
  border-top: 1px solid #ccc;
  margin-bottom: 2em
}

footer span {
  display: none;
}

img {
  max-width: 100%
}
pre.sourceCode span.st {
  color: #366354
}
pre.sourceCode span.kw {
  color: #397460
}
pre.sourceCode span.fu {
  color: #8f4e8b
}
pre.sourceCode span.ot {
  color: #2e659c
}
pre.sourceCode span.dt {
  color: #4F4371
}
pre.sourceCode span.co {
  color: #666
}
  </style>
  </head>
  <body>
    <div class="page-wrap">
      <h1>“Value polymorphism”, simple explanation with examples</h1>
<p class="author">By <a href="https://chrisdone.com/">Chris Done</a></p>

<p>A concept in Haskell which is particularly novel is that polymorphism works at the value level rather than function-parameter or object-dereference level.</p>
<p>Function-parameter polymorphism comes in some different forms, for example, C++:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> draw(Circle c){ … }
<span class="dt">void</span> draw(Triangle t){ … }
draw(circle); <span class="co">// draws a circle</span></code></pre>
<p>Function overloading is a type of function-parameter polymorphism. Generic functions in Common Lisp are another way to have function-parameter polymorphism:</p>
<pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(<span class="kw">defgeneric</span><span class="fu"> draw </span>(shape))
(<span class="kw">defmethod</span><span class="fu"> draw </span>((shape circle)) …)
(<span class="kw">defmethod</span><span class="fu"> draw </span>((shape triangle)) …)
(draw circle) <span class="co">;; draws a circle</span></code></pre>
<p>Object-dereference (or message passing) polymorphism is common to most object oriented languages. Depending on the object, the function/message will do something different:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Circle { <span class="dt">void</span> draw(){ … } }
<span class="kw">class</span> Triangle { <span class="dt">void</span> draw(){ … } }
circle.draw(); <span class="co">// draws a circle</span></code></pre>
<p>To avoid confusion, Haskell also has function parameter polymorphism, like C++ and Common Lisp above:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Drawable</span> a <span class="kw">where</span><span class="ot"> draw ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bitmap</span>
<span class="kw">instance</span> <span class="dt">Drawable</span> <span class="dt">Circle</span> <span class="kw">where</span> draw <span class="fu">=</span> …
<span class="kw">instance</span> <span class="dt">Drawable</span> <span class="dt">Triangle</span> <span class="kw">where</span> draw <span class="fu">=</span> …
draw circle <span class="co">-- draws a circle</span></code></pre>
<p>But more generally, Haskell has <em>value</em> polymorphism, which is that any value can be polymorphic and will be instantiated to a class instance depending on type signature or annotation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Default</span> a <span class="kw">where</span><span class="ot"> def ::</span> a
<span class="kw">instance</span> <span class="dt">Default</span> <span class="dt">Int</span> <span class="kw">where</span> def <span class="fu">=</span> <span class="dv">0</span>
<span class="kw">instance</span> <span class="dt">Default</span> <span class="dt">Char</span> <span class="kw">where</span> def <span class="fu">=</span> <span class="ch">'a'</span></code></pre>
<p>The type of an expression <code>def</code> therefore is <code>Default a =&gt; a</code>, or, “any instance of <code>Default</code>”. I can instantiate an instance myself by specifying a type signature:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt;<span class="ot"> def ::</span> <span class="dt">Int</span>
<span class="ot">→</span> <span class="dv">0</span>
λ&gt;<span class="ot"> def ::</span> <span class="dt">Char</span>
<span class="ot">→</span> <span class="ch">'a'</span></code></pre>
<p>Or by type inference, meaning that the combination of this expression with other expressions allows the compiler to infer the single correct type instance:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; def <span class="fu">:</span> <span class="st">&quot;bc&quot;</span>
<span class="ot">→</span> <span class="st">&quot;abc&quot;</span>
λ&gt; def <span class="fu">-</span> <span class="dv">2</span>
<span class="ot">→</span> <span class="fu">-</span><span class="dv">2</span>
λ&gt; def <span class="fu">==</span> <span class="dv">0</span>
<span class="ot">→</span> <span class="dt">True</span></code></pre>
<p>But with no information it will be a static compile error:</p>
<pre><code>λ&gt; def
Ambiguous type variable `a' in the constraint:
  `Default a' arising from a use of `def' at
    &lt;interactive&gt;:1:0-2
Probable fix: add a type signature that fixes these type
              variable(s)</code></pre>
<p>Why is value polymorphism beneficial? Some trivial examples follow (and you are trusted to extrapolate to the more sophisticated things that might otherwise obscure the essence of this feature).</p>
<p>The <code>Read</code> class contains a method <code>read</code> which is polymorphic on the return value:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Read</span> a <span class="kw">where</span>
<span class="ot">  read ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</code></pre>
<p>It parses a data type from a string. Combined with the <code>Show</code> class, together <code>Read</code> and <code>Show</code> make a naive serialization library. In the same way, it would be ambiguous to read without specifying the instance:</p>
<pre><code>λ&gt; read &quot;2&quot;
Ambiguous type variable `a' in the constraint:
  `Read a' arising from a use of `read' at
    &lt;interactive&gt;:1:0-7
Probable fix: add a type signature that fixes these type
              variable(s)</code></pre>
<p>But specifying with a type signature or using type inference are fine:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; read <span class="st">&quot;2&quot;</span><span class="ot"> ::</span> <span class="dt">Int</span>
<span class="ot">→</span> <span class="dv">2</span>
λ&gt; read <span class="st">&quot;2&quot;</span> <span class="fu">*</span> <span class="dv">3</span>
<span class="ot">→</span> <span class="dv">6</span></code></pre>
<p>Another example is JSON parsing (the real class is different to this, but introduces questions that are irrelevant to the point of this post).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">JSON</span> a <span class="kw">where</span>
<span class="ot">  decode ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> a</code></pre>
<p>The <code>decode</code> function is return-value polymorphic, it can be read like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">decode ::</span> (<span class="dt">JSON</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> a</code></pre>
<p>That is, it returns a result (success or fail) with a value which is an instance of the JSON class.</p>
<p>So both specifying an instance or using inference works:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; decode <span class="st">&quot;1&quot;</span><span class="ot"> ::</span> <span class="dt">Result</span> <span class="dt">Int</span>
<span class="ot">→</span> <span class="dt">Ok</span> <span class="dv">1</span>
λ&gt; <span class="kw">do</span> x <span class="ot">&lt;-</span> decode <span class="st">&quot;1&quot;</span>; return (x<span class="fu">*</span><span class="dv">3</span>)
<span class="ot">→</span> <span class="dt">Ok</span> <span class="dv">3</span></code></pre>
<p>And it works however complex you want to go with your types:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; decode <span class="st">&quot;[[1,\&quot;a\&quot;,{\&quot;x\&quot;:3}],[1,\&quot;a\&quot;,{\&quot;x\&quot;:2}]]&quot;</span>
<span class="ot">   ::</span> <span class="dt">Result</span> [(<span class="dt">Int</span>,<span class="dt">String</span>,<span class="dt">JSObject</span> <span class="dt">Int</span>)]
<span class="ot">→</span> <span class="dt">Ok</span> [(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>,<span class="dt">JSONObject</span> {fromJSObject <span class="fu">=</span> [(<span class="st">&quot;x&quot;</span>,<span class="dv">3</span>)]})
     ,(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>,<span class="dt">JSONObject</span> {fromJSObject <span class="fu">=</span> [(<span class="st">&quot;x&quot;</span>,<span class="dv">2</span>)]})]</code></pre>
<p>Thus by merely specifying the return type we have effectively generated a parser. An invalid string will produce an error:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ&gt; decode <span class="st">&quot;[[1,\&quot;a\&quot;,{\&quot;x\&quot;:3}],[1,\&quot;a\&quot;]]&quot;</span>
<span class="ot">  ::</span> <span class="dt">Result</span> [(<span class="dt">Int</span>,<span class="dt">String</span>,<span class="dt">JSObject</span> <span class="dt">Int</span>)]
<span class="ot">→</span> <span class="dt">Error</span> <span class="st">&quot;Unable to read Triple&quot;</span></code></pre>
<p>In fact, the literal <code>1</code> is also polymorphic with type <code>Num a =&gt; a</code>, meaning that the number could be an <code>Integer</code>, a <code>Double</code>, a <code>Rational</code>, or a user-defined type like <code>Scientific</code>. It will be determined by inference or annotation.</p>
<p>Such static value polymorphism is difficult to do in popular languages such as C#, Java, C++, without some kind of proxy objects to explicitly instantiate an object to dereference using generics or templates, and hard to do in Lisp, Python, Ruby and JavaScript without static type systems (although can also be approximated with proxy aka “witness” objects). This is, for example, why implementing the Monad class is rather awkward in other languages.</p>
<p>The list goes on. More examples include database query results, string literals, monoids, monads, …</p>
<p>Lastly, the <code>Default</code> class is a real class and in common use today.</p>

<footer>
  © 2011-10-16 Chris Done &lt;chrisdone@gmail.com&gt;
<span style="float:right"><a href="../rss.xml">RSS</a></span>
</footer>

    </div>

  </body>
</html>
